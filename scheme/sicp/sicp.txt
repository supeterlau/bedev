racket *.rkt

scheme *.ss *.scm

(+ 3 5 5 4 5) = 22

https://mitpress.mit.edu/sites/default/files/sicp/code/index.html

ch1 构造 过程抽象

1.1 程序设计基本元素

每种强大语言都会提供三种工具

  基本表达形式
  组合的方法 从较简单形式组合出复杂形式
  抽象的方法 为复杂形式命名，将复杂形式作为单元操作

程序设计处理两类要素: 过程 数据

数据 我们想操作的东西

过程 有关操作数据的规则描述

任何强大语言需要能表述 基本数据 和 基本过程，能提供对过程和数据进行组合和抽象的方法。

先处理简单的数值数据

1.1.1 表达式

400

(+ 400 100)

以上是一个组合式，括号表示过程应用。最左侧为运算符（要应用的过程）其他都是运算对象。运算符位于所有运算对象左边，为前缀表示。

优势是适用于带有任意个实参，而不产生歧义。

(+ 21 35 12 7)

同时前缀表示允许组合式嵌套 (+ (* 3 5) (- 10 9))

1.1.2 命名 和 环境

提供通过名字使用计算对象的方式，名字标识符即变量。

(define size 2)

define 是最简单的抽象方法，允许用名字引用 组合运算结果

关联值和符号，又能取出符号中的值，这种存储为 环境（全局环境）

1.1.2 组合式求值

求值组合式
  求值组合式各个子表达式
  将最左子表达式（运算符）应用于其他子表达式（运算对象）的值

这是一个递归的过程。在自己的工作步骤中，包含着调用规则本身的需要。

可以用树形图表示组合式求值过程。

每个组合式用带结点的分支表示，分支对应组合式中的运算符和各个运算对象。

终端结点（末端）表示运算符或数值。（无法再有分支）

从终端结点开始，在越来越高的层次中组合。

递归是处理层次性结构的强有力武器。

值向上求值，被称为 树形累积

反复应用求值子表达式，总会到达某一点，这里遇到的不是组合式而是基本表达式，（数 内部运算符或其他名字）
  数表示的值就是对应数值
  内部运算符对应值是机器指令序列
  其他名字的值是在环境中与名字关联的对象

第二种是第三种的特殊情况。

环境就是用于确定表达式中各个符号的意义。

(define x 3) 并不是组合式，应为不是将 define 应用于两个参数。它是 特殊形式。

特殊形式有自己的求值规则。

1.1.4 复合过程

程序设计包括
  数和算术运算符，基本数据和过程
  组合式嵌套，提供一种组织多个操作的方法
  定义，一种受限的抽象，为名字关联相应的值

过程定义 （函数），为复合操作提供名字，将复合操作作为单元使用。

(define (square x) (* x x))

square 又可以被用作基本构件组成其他复合操作。

1.1.5 过程应用的代换模型

复合过程中过程应用计算流程

  将复合过程应用于参数，将过程体中每个形参用相应实参取代后，对过程体求值

  对一个复合过程的求值，被归约为对另一个组合式的求值

执行求值的方式有多种

先对运算符和各个运算对象求值，将得到的过程应用于得到的实际参数。先求值参数，而后应用，应用序求值。

先不求出运算对象的值，直到实际需要值时再求值。完全展开而后归约，正则序求值。

Lisp 采用应用序求值，避免表达式的重复求值。

1.1.6 条件表达式和谓词

依据检测结果确定要做不同的操作

特殊形式 cond 

(cond ((> x 0) x))

符号 cond 后边很多 子句，子句中是表达式对偶 (<p> <e>)

对偶中第一个表达式是 谓词，被解释为（求值）真或假 true / false

cond 直到发现某个谓词为真为止，返回对应子句中 序列表达式 <e> 的值，作为整个 cond 表达式的值。如果找不到，cond 值就没有定义。

cond 中的 else 是一个特殊符号，当 else 前的 cond 子句都被跳过，会返回 else 后 <e> 的值。其实，所有求值为真的表达式都可以替代 else。

(define (abs x)
  (if (< x 0)
      (- x)
      x))

特殊形式 if，用于只有两种情况时

(if <p> <e1> <e2>)

(and <e1> ... <en>) 特殊形式，子表达式不一定会求值

(or <e1> ... <en>) 特殊形式，子表达式不一定会求值

(not <e>) 普通过程

1.1.7 牛顿法求平方根

平方根定义并没有给出一个计算过程，即给定一个数，如何实际找到这个数的平方根

数学函数 描述一件事情的特征

过程 描述如何去做一件事

即 说明性知识和行动性知识的差异

对 x 的平方根有一个猜测 y，通过求出 y 和 x/y 的平均值（更逼近实际平方根值

(define guess 1)

(define (sqrt x)
  (/ (+ (/ x guess) guess) 2))

(define (sqrt-iter guess x)
 ...)

1.1.8 过程作为黑箱抽象

sqrt-iter 的定义是递归的，一个过程的定义基于自身。

sqrt 反映 从原问题到子问题的分解

分解中的每一个过程完成了可以清楚标明的工作，可以作为定义其他过程模块。

如 square 过程。无须关注过程如何计算的，只需要注意能计算出平方值的事实

与其说 square 是过程，不如说是过程的抽象 即 过程抽象。适用于任何能计算出平方的过程。

一个过程定义应该能隐藏起一些细节。

- 用户不用关心形参名字。

过程的意义不依赖于形参名字。

过程形式参数在过程体中很重要。具体名字没有关系，这样的名字标识符为 约束变量。过程的定义，约束了所有形式参数，形式参数名字的改变，不改变过程定义。如果变量不是被约束的，那就是自由变量。

名字标识符定义被约束的那些表达式就是这个名字的作用域。

约束变量的作用域就是过程体。

- 内部定义和块结构

将一个过程依赖的子过程局部化。

目的，让其他函数也能使用自己的过程名 good-enough? 而不被 sqrt 独占

子过程中共有的约束变量，没有必要在子程序间传递，可以将它作为 sqrt 中的内部自由变量。

在调用 sqrt 时，x 从实参中得到值，这种方式是 词法作用域 （在定义本过程的环境中寻找对应变量值）
