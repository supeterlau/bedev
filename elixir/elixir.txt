WIP: 376 (4/27)

tour: https://elixir-lang.org/getting-started/introduction.html

# Introduction

elixir -v

iex: aliased to iex --erl "-kernel shell_history enabled"

"hello" <> " world" 连结字符串

脚本运行

elixir simple.exs

elixir --version

mix run

Vim Support:

git clone https://github.com/elixir-editors/vim-elixir.git ~/.vim_runtime/my_plugins/vim-elixir

Quote:

Instead of asking “how to do X in Elixir”, ask “how to solve Y in Elixir”.
In case things are not working as expected, please include as much information as you can in your report.

# 2 Basic type

integer, 1 0X1f
float, 1.0
boolean, true false
atom, :atom / symbol
string, "elixir"
[1,2,3] 'elixir', list
{1,2,3}, tuple

1.1 数值计算

默认是浮点计算

div rem 提供整数计算

div 2,3

rem(45,13)

支持 binary octal hexadecimal 数字
  0b1010
  0o777
  0x1F 0x1f

支持 浮点数科学表示

1.0e-10 , 64-bit double precision

round 得到最近的整数
trunc 得到整数部分

1.2 functions

Functions 包含函数名和函数参数个数 (参数类型 ?)

round/1 round/2

iex 显示帮助 h round/1; h +/2

1.3 Booleans

true false

is_boolean(true)
is_boolean(nil) false
is_nil(nil)

is_integer/1
is_float/1
is_number/1

1.4 Atoms

全小写，常量，值就是自己变量名。常用于表示操作状态 :ok, :error

true false 也是 atoms

is_atom(false) -> true
false == :false -> true

is_boolean(:false)

alias (别名)结构，首字母大写，是 atoms

例如 Hello 可用做模块名

is_atom(Erlang) -> true

1.5 Strings

double quotes 是 UTF-8 编码

支持字符串内插 变量写入字符串 "Hello #{:world}"

(Atom.to_string :world) == "world"

字符串内部可以使用 转义字符

IO.puts "Good\nLuck" -> :ok

Elixir 中的 Strings 在内部使用连续 binaries 表示的

is_binary("Hello") -> true

byte_size("Hello") -> 5

byte_size("hellö") -> 6

有 5 个字符，但占用 6 个字节大小。因为最后一个字符在 UTF-8 中用 2 bytes 表示

字符数 String.length("hellö")

方法来自 String 模块 操作 Unicode 字符

bit -> bitstring -> binary (8的倍数的 bitstring)

charlist 多用于和 Erlang 交互中

1.6 Anonymous Function

add = fn a, b -> a + b end

匿名函数

-> 左边是参数 右边是函数体 以 end 结尾

匿名函数保存在 add 中

调用函数 add.(4, 6) 需要用 .

区分 named function add/2 和匿名函数

named function 只能在 Modules 中定义

匿名函数内部的 变量赋值不影响外部环境

1.7 Lists (Linked)

a list of values, value 可以是任意类型

[1, 2, :ok, true]

列表长度 length

length [1, 2, :ok]

注意 list 是链表，计算长度需要遍历整个列表

合并列表 ++/2

从第一个列表中删除第二个列表中出现的元素 --/2

对 list 的操作不修改原始 list。添加或删除元素都会返回 新 list。

Elixir data structures are immutable.

no one will mutate data in memory - only transform it.

获取 list 的 head 和 tail

hd some_list

tl some_list

如果操作对象为 [] 则会报错

ArgumentError

有时候 list 会返回单引号值

原因在于当 Elixir 发现 list 中元素为可打印 ASCII 数字时，会将 list 当作 charlist 打印出来

iex 中 ?\v 可以查看对应的数字

charlist 在同 Erlang 代码交互时常见。

i 'hello' 可以查看 value 信息

单引号的是 charlists

双引号的是 字符串。二者不同。

1.8 Tuples

Elixr 用大括号表示 元组

元素可以是任意类型

{"Good", :ok}

tuple_size 元组大小

元组存放在连续内存中，通过索引或计算元组长度是快速操作。（随机访问

0-based 索引

获取元素

elem(tuple, 1)

修改元素

put_elem(tuple, 1, "New Element")

如果越界会报错，ArgumentError

1.9 Lists or tupels

List 是链表 linked list

合并列表取决于 left-hand 列表的长度

慢速操作 获取长度，按索引获取单个元素

Tuple 是连续内存。

获取长度和根据索引获取元素很快。更新和添加元素很慢，因为需要创建新的 Tuple

当你更新 tuple 时，除了被修改元素外，新旧元素是共享的。从而减少内存分配操作。

tuple 常用于从函数中返回额外信息，如操作成功与否。

大部分时候，Elixir 会指导你如何选择数据类型。

比如有访问 tuple 元素函数 elem 而没有对应的访问 list 元素的函数

计算数据结构元素个数的函数命名有一个简单的规则。

如果时间复杂度为常数时间。则命名为 size。如果是线性时间，则命名为 length (linear 和 length 都是 l 开头)

byte_size/1
tuple_size/1

length/1
String.length/1

Elixir 还提供 Port Reference PID

# 3 Basic operators

数值运算

+ - * / div/2 rem/2

列表操作符 ++/2 --/2

字符串连接 <>

布尔运算符

左右操作数必须是布尔值 true false

true and true (or and not)

false and raise("Error will never be raised")

and 对应 Erlang andalse

or 对应 Erlang orelse

|| && ! 操作数可以是任意类型

* 除 false nil 外的值都被求值为 true

nil && 13

比较 == != === <= >= < >

=== 在比较整数和浮点数时更严格

1 == 1.0 true

1 === 1.0 false

不同类型之间可以做比较

number < atom < reference < function < port < pid < tuple < map < list < bitstring

# 4 Pattern matching

操作符 = 在 Elixir 中实际是 匹配操作符

pin 操作符 ^ 可以用来获取变量绑定的值

1. match 操作符

x = 1

x
=> 1

2 = x 会导致 MatchError

1 = x 是有效表达式，因为左右的值相等

变量只能在 = 左侧才能被赋值

1 = unknown 中会被解释为试图调用 unknown/0 而这个函数不存在

CompilerError undefined function

2. 模式匹配

match 操作符不仅仅用于匹配简单数据，还能用于匹配更复杂的数据类型。

如 tuple

{a, b, c} = {:hello, "WORLD", 42}

如果无法匹配，则出现 MatchError

无法匹配的原因: 长度不同或类型不同，已有数据不匹配

{:ok, result} = {:ok, 13} 可以匹配

{:ok, result} = {:error, 13} 无法匹配 报错

可以匹配 List

[a,b,c] = [11,12,13]

匹配头部尾部

[head | tail] = [11,12,13]

(当然无法匹配 [] 空列表) 类似 hd/1 tl/1

添加列表头部

[0 | some_list]

Pattern matching allows developers to easily destructure data types such as tuples and lists.

destructure data types.

3. pin 操作符

Elixir 的变量可以 rebound Erlang 不允许 rebound

如果不希望变量被 rebound

可以使用 pin 操作符 ^

x = 1

^x = 2 (MatchError)

可以用于模式匹配中

{y, ^x} = {2, 1}

y => 2

当 x 很复杂时可以用 ^x 替代

{x, x} = {1, 2}

多次使用一个变量，这个变量必须指向一个值。

[head | _] = [1,2,3]

_ 允许忽略某个值

_ 特殊之处，无法读取其中的值

pattern matching 的 left side 不能是函数调用 function call

# 5 case, cond, and if

control flow structures

1. case

case {1, 2, 3} do
  {1, x, 3} ->
    "match, bind x to 2"
  _ ->
    "match forever"
end

匹配已有变量可以用 pin 操作符 ^x

case 分支(leg, case clause) 可以用过 guard 添加条件

  when x > 0

  guard 中的错误不会 leak 出来，只会导致 guard fail 即不满足条件

没有匹配的分支会报错

匿名函数允许有 多个分支和使用 guard

  但多个分支要求参数个数必须一致

2. cond

需要匹配不同值时使用

cond do
  2 + 2 == 5 ->
    "not true"
  2 * 2 == 3 ->
    "not true again"
  1 + 1 == 2 ->
    "true"
end

类似 imperative languages 中的 else if 语句

如果所有条件都返回 nil 或 false 会抛出错误 CondClauseError

最好总是提供 true -> "always true"

nil false 外的值都是 true

3. if 和 unless

if/2 unless/2 是 宏 macro

都支持 else block

if unless else 属于 Kernel 模块，这个模块定义的宏和函数都被自动导入

4. do/end 语法块 blocks

if true do
  1+2
end

可以写成

if true, do: 1+2

if false
  :this
else
  :that
end

写成

if false, do: :this, else: :that
  常规的语法 每个参数之间用 逗号 隔开

if %false% %do: :this% %else: :that%

if true do
  a = 1+2
  a + 10
end

是

if true, do: (
  a = 1+2
  b + 10
)

的简化

do/end 总是 bound to the outermost function call

  当 if condition 前有函数等时要注意

# 6 Binaries, strings, and charlists

string = "hello"
is_binary(string)

1. Unicode 和 CodePoints 码点

Unicode 给我们已知的字符进行了编码。每个字符被分配一个唯一数值索引

?a ?字符 可以获得 code point

大部分 Unicode code chart 用 十六进制表示 code point

a => 97 => 0061 => elixir 中表示 "\u0061"

"\u0061" === "a"

2. UTF-9 和 编码

code point 是 what we store, 计算机里存储的东西

encoding 是 how we store it, 计算机存储的方式

  一种机制，将 code point 数字转为 bytes

Elixir 使用 UTF-8，即 codde points 被编码成一系列 8-bit 的 bytes

UTF-8 是变长编码，使用 1 - 4 字节存储每个 codepoint

除了定义字符， UTF-8 还提供了 graphemes notion，即将多个字符显示为一个。

é 可以表示为一个字符，也可以表示为两个字符的组合

string = "hełło"

String.length 和 byte_size 不同

第一个计算 graphemes 第二个计算 raw bytes

Elixir 中查看 inner binary 的技巧

"aaa" <> <<0>>

或者用 IO.inspect("aaa", binaries: :as_binaries)

3. Bitstrings

bitstring 是 Elixir 的基础类型 <<1,2,3>>

bitstring 是内存中连续的比特

默认情况使用 8bits 1byte 来存储 bitstring 中的每个数字，但是可以通过

::n ::size(n) 来人为指定

<<3::4>> <<3::size(4)>>

十进制 5
二进制形式是 0101

超出可存储范围的数值会被截取掉

  <<1::8>> === <<257::8>>

4. Binaries

binary 基于 bitstring, bitstring 中 bit 数量能被 8 整除的叫 binary

every binary is a bitstring

not every bitstring is a binary

is_bitstring/1 is_binary/1

binary / bitstring 中可以使用 pattern match 模式匹配

<<0, 1, x>> = <<0, 1, 2>>

不使用 0:: 时默认每个实体匹配 1 byte 8 bits

匹配未知长度的 binary 可以用 ::binary

<<0,1,x::binary>>=<<0,1,2,3>>

:: 后边的是 modifier 其他 modifier 有

::binary-size(n) 匹配 n bytes 的 binary

string 是 UTF-9 编码的 binary 即 << >> 可能是 string

every string is a binary

not every binary is a valid string

String.valid?/1 判断是否为 String

因此字符串连接符 <> 实际为 binary 连接符

string 中也可以用模式匹配

<<head, rest::binary>> = 'usa'

需要注意 string 的模式匹配是针对 bytes 的而不是 chars

一个 char 可能占用多个 bytes

当在 string 中用模式匹配是，要加上 utf8 modifier

<<x::utf8, rest:binary>> = "über"

5. Charlists

charlists 是 intergers 列表，每个 integers 都是合法 code points

'hello' charlists

is_list 'hello'

List.first 'hello'

iex 默认输出 0-127 code point 的字符形式，超出范围的只输出 整数

改变这种行为需要用

IO.inspect('hello', charlists: :as_lists)

charlist to string

to_string/1

to_charlist/1

这两个函数也用于 integer atom 等

charlist 是 list 因此连接符号是 ++

# 7 Keyword lists and maps

两种主要的 associative data structure: keyword lists 和 maps

1. Keyword lists

a list fo 2-item tuples 并且第一个元素是 atom 被成为 keyword list

atom 是 key

list = [{:a, 1}, {:b, 2}]

简写为 [a: 1, b: 2]

keyword list 也是 list 支持所有 list 操作

list ++ [c: 3]

list[:a] 会返回第一个 a 对应的值

keyword lists 特性

  keys 是 atoms
  有序的，开发者指定
  可以有多个同样的key

if false, do: :this, else: :that

if( false, [do: :this, else: :that] )

if( false, [{:do, :this}, {:else, :that}] )

由此可见，如果 keyword list 是 函数/宏 的最后一个参数，则可以省略 [] 中括号

keyword lists 中可以用 模式匹配，但实际中很少使用。因为必须要求数量和顺序一致。

Elixir 提供 keyword 模块来操作 keyword lists

keyword lists 是 list，因此找 key ，计算长度等是线性操作。

在 Elixir 中常用于 传递 optional 值

如果需要存储大量值，并要求 key value 最多一一对应，应该使用 map

guarantee one-key associates with at maximum one-value

2. Maps

store key-value

map = %{:a => 1, 2 => :b}

  允许任何值作为 key

  key 是无序的

very useful with pattern matching 总是可以匹配到 subset

%{} 匹配任意 map

%{:a => a} = %{:a => 1, 2 => :b}

变量可以用于获取 匹配(pin) 添加 key

n = 1
map[n]
map = %{n => :one}
%{^n => :one} = %{1=>:one,2=>:two,3=>:three}

Map 模块提供方便操作 map 的函数

Map.get(map, :a)

Map.put(map, :c, 3)

Map.to_list(map)

更新 value:

%{ map | 2 => "two" }

不能更新不存在的 key

当key都是 atom 时，可以简写为 map = %{:a=>1,:b=>2}

map == %{a: 1, b: 2}

同时有新方法获取 value

map.a == 1

map.c (访问不存在的 key: KeyError)

尽量使用 map.field 语法和模式匹配来替代 Map 模块的方法

这种写法叫做 assertive style of programming (https://dashbit.co/blog/writing-assertive-code-with-elixir)

3. Nested data structures

开发中可能会用到 maps inside maps, keywords list inside maps 等。 Elixir 中有类似 put_in/2 update_in/2 等其他 macros 提供类似 imperative language 的函数，同时保证 immutable。

users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]

users[:john].age

users = put_in users[:john].age, 31

update_in/2 macro 类似 put_in 但是允许传入函数控制数据变化

users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end

其他还有

get_and_update_in/2 一次完成获取数据，更新数据

put_in/3

update_in/3

get_and_update_in/3 允许动态访问数据结构

# 8 Modules and Functions

多个函数可以被打包为模块 modules。我们已经使用过很多种模块，String

String.length("Erlang")

通常我们将模块写入文件 math.ex

使用 elixirc 编译到字节码文件 Elixir.Math.beam

在同样目录中启动 iex

用 Math.sum(1,2) 调用模块中函数

Elixir 项目习惯

  ebin 包含编译后字节码
  lib  包含 elixir 代码 .ex 文件
  test 包含测试 .exs 文件

实际项目中使用 mix build 工具

脚本模式 scripted mode，不会产生字节码

2. Scripted mode

Elixir 对待 .ex 和 .exs 文件流程大致相同，只是 .exs 文件不会被编译。但执行中，它们都被编译到内存中，只有 .ex 文件会保存字节码到硬盘 .beam 文件。

elixir math.exs

3. Named functions

在模块中，我们可以用 def/2 或 defp/2 定义公共或私有函数。

def/2 定义的函数可以在其他模块中调用，defp/2 定义的函数只能在模块内调用

函数定义支持 guards 和 多语句。当函数有多语句时，Elixir 会尝试每个语句直到找到匹配的函数签名 name/ariry。

zero? 这种形式表示函数返回 布尔值

类似 if 结构， named functions 支持 do: 和 do/end 语法

def zero?(0) do
  true
end

可以写做

def zero?(0), do: true

do: 单行

do/end 多行

4. 函数捕获 Function capturing

name/arity 可以用来指代特定函数，也可以用于表示函数类型 function type

Math.zero?(0)

fun = &Math.zero?/1

is_function(fun)

调用匿名函数 fun.(0)

(Erlang:

Fn = fun(X) -> X + 1 end.

函数调用 Fn(1).)

Elixir 中区分了 anonymous 函数和 named 函数，前者必须用 . 调用。

fun = fn x -> x + 1 end

shortcut:

fun = &(&1 + 1)

fun2 = &"Good #{&1}"

fun2.("morning")

&Module.function() 可以 capture 模块中的函数

fun = &List.flattern(&1, &2)

5. 默认参数 Default arguments

Named functions 支持默认参数

def join(a, b, sep \\ " ") do
  a <> sep <> b
end

任意表达式都可以作为 默认参数，但在定义函数时不会被求值。

函数调用是才求值

如果有默认参数的函数，有多条语句 multiple clauses。要求创建一个 函数头

def join(, b \\ nil, sep \\ " ")

使用默认参数要注意避免多语句之间互相覆盖

# 9 Recursion

1. 用递归实现循环 Loops through recursion

由于 immutability Elixir 和任何 functional programming language 中 loops 和 imperative languages 不同。 类似 C 的语言中循环是

for(i=0; i< sizeof(array);i++) {
  array[i] = array[i] * 2;
}

Elixir 中依赖 recursion 实现循环

递归调用函数，直到达成某个条件停止递归

No data is mutated in this process

持续递归调用直到满足 base case

2. reduce 和 map

利用递归求和

[], accu 作为 base case, 当list中为空时，求得的值保存在 accu 中

递归和尾调用优化是 Elixir 重要部分，常用来实现 loop

Enum 模块已经提供了很多方便的方法

Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)

Enum.map([1,2,3], fn(x) -> x * 2 end)

简写为

Enum.reduce([1,2,3], 0, &+/2)

Enum.map([1,2,3], &(&1 * 2))

# 10 Enumerables and stream

Elixir 中有 enumerables 概念，并且提供了 Enum 模块来处理它们

Enum.map(%{1=>2, 3=>4}, fn {k, v} -> k * v end)

模块中有大量函数用于 transform sort group filter 和 retrieve items from enumerables

也提供了 ranges

Enum.map(1..3, fn x -> x * 2 end)

不过这些函数都限于 枚举 数据结构中的值。如果要添加，更新元素，需要用特定数据结构模块提供的函数。

如 List.insert_at/3

Enum 模块的函数是 多态 的 polymorphic。因为它们可以用于多种数据结构，只需要这种结构实现 Enumerable 协议。（协议，接口）

2. Eager vs Lazy

Enum 模块中函数都是 eager 函数 （即时求值）。很多函数要求传入 enumerable 返回 list

当用 Enum 中函数进行多步计算时，每次函数调用都会产生中间 list

如

1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(add?) |> Enum.sum

3. pipe 操作符 |>

|> 符号，将 left side 表达式的输出作为 right side 函数的第一个参数

可以 highlight 被转换的数据

4. Streams

Elixir 提供 Stream 模块作为 Enum 的 lazy 操作备选。

1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum

Streams are lazy, composable enumerables

streams 构建一系列计算，只有将 stream 传入 Enum 模块函数是才被调用。

Stream 适用于 large, possibly infinite, collections

Stream 模块函数，参数为 任意 enumerable 返回值为 stream

也有创建 stream 的函数。如 Stream.cycle/1 根据参数创建无限循环 stream

Stream.unfold

def unfold(next_acc, next_fun)

@spec unfold(acc(), (acc() -> {element(), acc()} | nil)) ::
        Enumerable.t()

Emits a sequence of values for the given accumulator.

Successive values are generated by calling next_fun with the previous
accumulator and it must return a tuple with the current value and next
accumulator. The enumeration finishes if it returns nil.

Stream.resource/3 用于资源封装，保证资源正常打开和关闭。

Fiel.stream!/1 是基于 Stream.resource 的

stream = File.stream!("path/to/file")

Enum.take(stream, 10) fetch 前 10 行

streams 可以用于处理大文件和网络资源

一般优先使用 Enum 函数，当需要 laziness 操作时使用 Stream

# 11 Process

Elixir 中，代码都是在 processes 中运行的。Processes 之间互相隔离 isolated，并发运行，并通过 message passing 通信。

Processes 仅仅是 Elixir concurrency 的基础，但它们也提供了 build distributed 和 fault-tolerant programs 的方法。

Elixir Processes 不是操作系统进程。Elixir 中的 Processes 很 lightweight，甚至比有些语言中的线程更轻量。

因此很容易同时运行，tens or even hundreds of thousands of processes

1. spawn

启动新 processes 方法是用自动导入的 spawn/1 函数

spawn fn -> 1 + 2 end

spawn 的参数是在新建 process 中运行的函数

spawn 的返回值是 PID (process identifier)

被启动的进程会运行函数并在运行完毕后退出

Process.alive?(pid) 查看进程是否退出

self() 获取当前所在 process pid

2. send 和 receive

用 send/2 发送 messages 用 receive/1 接收 messages

当 message 被发送到 process，它被存放在 process mailbox。

receive/1 遍历当前 process mailbox 寻找能匹配给定模式的 message。

receive/1 支持 guards (when is_integer?(x)) 和 多语句。

发消息的 process 不会在 send/2 处阻塞，它将消息放在接收方 mailbox 中，就继续运行其他代码。process 可以给自己发送 messages。

mailbox 没有消息时，当前 process 会等待匹配消息到达。可以指定等待超时时间。

receive do
  {:hello, msg} -> msg
after
  1_000 -> "time out"
end

超时可以设置为 0。。。

inspect/1 可以将数据结构内部表示形式转为 string

flush/0 清空并打印 mailbox 中全部信息

3. Links

大多数时候我们以 linked processes 形式启动 process。没有 link 的 process 中出错时，process 打印 log，父进程继续运行。进程间是隔离，互不影响的。如果想让一个进程的错误传播到另一个进程，就需要将它们关联 link 起来。

spawn_link fn -> raise "oops" end

parent process 会接收到另一个进程的 EXIT signal

https://hexdocs.pm/elixir/Process.html

手动 link: Process.link/1

Creates a link between the calling process and the given item (process or port).

Links are bidirectional. Linked processes can be unlinked by using unlink/1.

通常将进程和 supervisors link，当 process 挂掉会原地创建新 process。

在 Elixir 中，失败的 process 可以期待被 supervisors 正确重启。"Failing fast" 是写 Elixir 程序的常见理念。

4. Tasks

大部分时候我们不会直接用 spawn/1 spawn_link/1 这么底层的函数，而是使用基于它们的抽象。例如 Task

Task 提供 better error reports 和 intropection (内省信息)

Task.start fn -> raise "task oops" end

Task.start/1 和 Task.start_link/1 返回 {:ok, pid} 而不仅是 pid。方便用于 supervision trees。

Task 还有 Task.async/1 Task.await/1 以及实现分布式的函数。

5. State

如果你的应用需要状态来保存配置，保存解析的文件，应该保存在哪呢？

Processes 是最常用的地方。我们可以写很多 loop infinitely 的进程来维护状态，收发消息。

defmodule KV do
end

iex kv.exs 可以加载 exs 中的模块

任何知道 pid 值的进程，都能给它发送 message

还可以给 pid 注册 name，根据 name 发送消息

Process.register(pid, :kv)

send :kv, {:get, :hello, self()}

使用 process 存储 state 及注册名字是很常见的模式。但大部分时候我们不会手动实现，而是用 Elixir 提供的很多抽象来实现，例如 agent 模块，就是 state 的抽象

{:ok, pid} = Agent.start_link(fn -> %{} end)

Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)

Agent.get(pid, fn map -> Map.get(map, :hello) end)

Agent.start_link 参数 name 可以自动注册名字。

除了 Agent，还有实现 generic servers 的 GenServer 等

将会在 Mix 和 OTP 指南中介绍。

# 12 IO 和 file system

简单介绍 input/output 机制和 file-system-related 功能，涉及模块 IO File Path。

1. IO 模块

reading writing to 标准输入输出 :stdio :stderr，files 和其他 IO 设备。

IO.puts("output")

IO.gets("input your name")

IO 模块默认从标准输入读，写入到标准输出。

可以用 :stderr 作为参数改变这一行为

IO.puts(:stderr, "Output to standard error")

2. File 模块

读取文件。默认以 binary 模式打开，使用 IO.binread/2 和 IO.binwrite/2 来读写。

可以指定用 :utf8 打开

File.read(path/to/file) utf8 编码

File 还提供很多 file system 相关函数

  File.rm/1
  File.mkdir/1
  File.mkdir_p/1
  File.cp_r/2
  File.rm_rf/1

变体 带 trailing bang (!)

  File.read!/1

  只返回文件内容，不返回 tuple，如果出错会抛出错误。

  没有 ! 的函数以模式匹配形式处理错误。

  如果你预期文件存在，要避免写 {:ok, body} = File.read(file)

  因为如果出错，错误信息将是 匹配错误，而不是文件不存在。如果不想处理错误，就使用 File.read!/1

3. Path 模块

File 模块以 paths 为参数。paths 是普通的 binaries。Path 模块提供处理 path 的函数。

Path.join("foo", "bar")

Path.expand("~/hello")

4. Processes

File.open/2 返回 tuple {:ok, pid}

File.open/2 返回 process，当你写入 file 时，实际是向 process 发送消息

IO.write(file, "content")

IO 模块需要特定的结果

用 process 代替 IO 设备，Erlang VM 允许 IO 消息在不同节点间传递，甚至跨节点交换文件。

5. iodata 和 chardata

IO 和 File 也允许使用 charlists 作为参数，也允许混用 charlists integers binaries

IO.puts(['hello', ?\s, "-world"])

list 可能表示 a bunch of bytes 或 a bunch of characters，取决于 IO 设备编码。

如果是未指定编码打开的文件，必须使用 IO 中 bin* 开头的函数。这些函数以 iodata 为参数，即 a list of integers 或 binaries

如果设备是 :stdio 或 utf8 编码文件，则使用其他函数。它们以 char_data 为参数，即 a list of characters 或 strings

Although this is a subtle difference, you only need to worry about these details if you intend to pass lists to those functions

# 13. alias, require, import

facilitate software reuse:

提供代码重用机制：

三种 directives: alias require import (都是 lexical scope)

一个 macro: use (allow used module to inject code)

alias Foo.Bar, as: Bar

  为模块创建别名

require Foo

  require 模块，使用其中的 macros

import Foo

  import 模块中的函数，可以省去 Foo. 前缀

use Foo

  调用 Foo 中定义的 custom code，作为 extension point

1. alias

alias Math.List, as: List

会覆盖默认的 List 模块

默认 List 模块指的是 Elixir.List 但是 Elixir 默认可以忽略。

覆盖后，仍然可以通过 Elixir.List 使用原 List 模块

alias Math.List 等价于 alias Math.List, as: List

alias 是 lexically scoped 意味着可以为不同的函数，不同作用域单独设置 alias

2. require

Elixir 提供 macros 作为 meta-programming 机制。Macros 在 compile time 展开

默认 public 函数可以直接通过模块使用，但 macros 需要 require 模块后使用

require Integer

Integer.is_odd(3)

Integer.is_odd/1 is defined as a macro so that it can be used as a guard

因为 is_odd 是宏，所以可以用于 guard

也是 lexically scoped。

3. import

可以省略模块名来使用其中的 public functions 和 macros

import List, only: [duplicate: 2] -> 引入 List.duplicate/2

除了 only 还有 :except

也是 lexically scoped。

4. use

use 会调用模块的 __using__/1 回调

use OtherModule, option: :value

编译为

require OtherModule
OtherModule.__using__(option: :value)

use allows any code to run, we can’t really know the side-effects of using a module without reading its documentation

推荐优先使用 import alias。

5. 理解 alias

首字母大写的 identifier，编译期转为 atom

String alias 转为 :"Elixir.String"

alias/2 改变 alias 展开成的 atom

alias 转为 atoms 是因为在 Erlang VM 中，模块以 atom 形式表示

例如调用 Erlang 函数

:lists.flattern([1,[2],3])

6. 嵌套 Module

defmodule Foo do
  defmodule Bar do
  end
end

与

defmodule Elixir.Foo do
  defmodule Elixir.Foo.Bar do
  end

  alias Elixir.Foo.Bar, as: Bar
end

一样

Bar 移出 Foo 后必须通过 Foo.Bar 访问

定义 Foo.Bar 前不需要定义 Foo 模块

alias 也保证 marcors 是 hygienic 的

7. 引入多个模块

Elixir v1.2 后，可以一次 alias import require 多个模块

alias MyApp.{Foo, Bar, Baz}

# 14. Module attributes

1. 作为注释 注解 As annotations

information to be used by user or VM

@vsn 被用作 code reload 机制，检查模块是否要更新

如果没有 @vsn，就以模块函数 MD5 作为 version

常用 attributes

  @moduledoc

  @doc

  @behaviour 指定 OTP 或自定义 behaviour

  @before_compile

Elixir 中 documentation 是 first-class 的，提供很多访问文档的函数

@moduledoc """

support Markdown

"""

elixirc module.ex 编译后才有文档

iex

h ModuleName 访问 @moduledoc

ExDoc 工具可以生成 HTML 格式

更多支持的 attributes: https://hexdocs.pm/elixir/Module.html#module-module-attributes

2. 作为 常量

让值更 visible 和 reuseable

@initial_state

与 Erlang 不同，用户定义的 attribute 只在 compilation time 存在。

通过调用 Module.register_attribute/3 使 attribute 行为类似 Erlang

访问为定义的 attribute 会引发 warning

每次读取 attribute，会获得它的当前值 snapshot，值在编译期读取而不是 runtime。这也使得 attribute 能用作 模块编译期 storage

正常情况下，重复赋值 attribute 会导致值变化。但你可以配置 attribute 累积值到 list

@param :foo
@param :bar
# @param == [:bar, :foo]

attribute 中可以调用函数（除本模块定义函数，因为本模块函数还未编译）

attribute name 和 value 之间不能换行

3. 作为临时存储 temporary storage

ExUnit

use ExUnit.Case, async: true

Next: structs / protocols / exception handling / sigils / comprehensions

# 15. Structs

map = %{a: 1, b: 2}

map[:a]

%{map | a: 3} => %{a: 3, b: 2}

structs 是扩展 map 的数据结构，提供 compile-time 检查和默认值。

1. structs 定义

要声明 struct 需要使用 defstruct

defstruct 参数为 keyword list 因此获取 value 可以用 . 操作符 john.name

struct 的名字为所在模块的名字

如果在另一个文件内定义 struct 在 iex 中需要通过

c("file.ex") 或 c("file.exs") 引入

defmodule User do
  defstruct name: "John", age: 27
end

compile-time guarantees 指的是只有通过 defstruct 定义的 fileds / keys 才允许出现在 struct 中

%User{oops: :field}

2. 获取 更新 structs

使用 key 为 atom 的 map 中 dot 操作符

john = %User{}
john.age

更新使用 map 语法

%{ john | name: "James" }

不能给 struct 添加新 key。这些 maps 可以共享 key structure in memory。

Struct 可以用于 pattern matching。

%User{name: name} = john
name => "John"

3. structs 底层实现是 maps

structs 底层是 有固定 fields 的 maps

structs 中有一个特殊的 fields __struct__，包含 struct 的 name

is_map(john) => true

john.__struct__

所谓 bare maps，是说 maps 中实现的 protocols 都不能在 struct 中使用

例如，无法遍历 struct 或 通过 key 获取 value

但是由于 struct 还是 map，可以使用 map 自己的方法

jane = Map.put(%User{}, :name, "Jane")

Map.merge

Map.keys

struct 自己的 protocols 提供重要特性 data polymorphism 数据多态。

4. structs 默认值和必需 key

如果你不指定默认值，默认值为 nil

defstruct [:name, age: 27]

混合使用不指定默认值参数和指定默认值参数时，要将不指定默认值参数放前边

顺序错误会引发 SyntaxError

@enforce_keys [:make] 指定必需有值的 field

# 16. Protocols

Protocols 是 Elixir 中实现多态 polymorphism 的机制。根据数据类型，有不同的行为。

多态可以通过 pattern matching 和 guard 实现

def type(value) when is_binary(value), do: "string"
def type(value) when is_integer(value), do: "integer"

为每个类型实现 type/1 函数，问题在于不好扩展 extend its functionality。

protocols 允许我们实现初始类型的函数。protocol 可以分发函数到实现 protocol 的任意数据类型。protocol 可以被任意类型在任意时刻实现。

定义 protocol

defprotocol Utility do
  @spec type(t) :: String.t()
  def type(value)
end

实现 protocol

defimpl Utility, for: BitString do
  def type(_value), do: "string"
end

调用 protocol 函数，类似模块

Utility.type(1000)

常用的 protocl 是 String.Chars 实现 to_string/1 函数会通知 Elixir Kernel 如何展示 custom structs

1. Example

描述元素个数 length size

length 表示需要通过计算才知道的数量，需要遍历 list

而 tupel_size byte_size 不需要计算 pre-computed

为不同数据类型实现通用 Size protocol

2. Protocols and structs

使用 struct 时，protocols 会更强大

struct 基于 map，但没有实现 map 的 protocol，比如 MapSet 是 struct

需要为 MapSet 实现 Size protocol : MapSet.size/1

利用 struct 可以实现更 robust 的数据结构，如 queues

defmodule User do
  defstruct [:name, :age]
end

defimpl Size, for: User do
  def size(_), do: 3
end

3. Implementing Any

为每种类型都实现 protocol 很麻烦。 Elixir 提供一些参数

可以指定某个类型自动继承 protocol 实现

可以自动为每个类型都实现 protocol

3.1 Deriving

defimpl Size, for: Any do
  def size(_), do: 0
end

defmodule Other do
  @derive [Size]
  defstruct [:name, :age]
end

指定继承 Size protocol，会使用 Any 对应的实现

3.2 Fallback to Any

另一种方式是在 protocol 中设置 fallback 为 Any

即在未找到对应类型的实现时，使用 Any 的实现

通常未找到实现要抛出 protocol is not implemented 错误

Elixir 开发者喜欢 explicit 胜过 implicit 因此多用 derive

4. Built-in protocols

Enum 模块针对实现 Enumerable protocol 的数据结构

String.Chars protocol

inspect 函数基于 Inspect protocol

  the protocol used to transform any data structure into a readable textual representation.

  IEx 就是用这个函数来显示结果的。

当 inspect 结果以 # 开头时，表示显示的信息可能有丢失

# 17. Comprehensions

# 18. Sigils

# 19. try catch and rescue

# 20. Typespecs and behaviours

# 21. Debugging

# 22. Erlang libraries

MIX AND OTP

# 1. Mix

# 2. Agent

# 3. GenServer

# 4. Supervisor and Application

# 5. Dynamic supevisors

# 6. ETS

# 7. Dependencies and umbrella projects

# 8. Task and gen_tcp

# 9. Doctests, patterns and with

# 10. Distributed tasks and tags

# 11. Configuration and releases

META-PROGRAMMING in ELIXIR

# 1. Quote and unquote

# 2. Macros

# 3. Domain-specific languages DSLs

=========

iex

command
  i Prints information about the data type of any given term
  h Helper
  v Returns the value of the nth expression in the history

http://elixirstatus.com/
https://elixirweekly.net/

https://elixirforum.com
https://elixirforum.com/t/phoenix-1-5-0-rc-0-released/30693
elixirmix

sidecar pattern

Code Gist
  liveview

orm or sql builder in Elixir/Erlang

algorithm
  c
  java
  python
  elixir / erlang
  Haskell

Graph Theory algorithms
https://www.youtube.com/watch?v=09_LlHjoEiY

https://www.tutorialspoint.com/data_structures_algorithms/index.htm

MIT 6.006 算法导论
https://www.youtube.com/watch?v=OQ5jsbhAv_M

Advanced Algorithms (COMPSCI 224), Lecture 1
https://www.youtube.com/watch?v=0JUN9aDxVmI

https://www.tutorialspoint.com/design_and_analysis_of_algorithms/index.htm

https://www.tutorialspoint.com/data_structures_algorithms/index.htm

剑指offer
编程之美
