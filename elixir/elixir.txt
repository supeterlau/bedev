WIP: 376 (4/27)

tour: https://elixir-lang.org/getting-started/introduction.html

# Introduction

elixir -v

iex: aliased to iex --erl "-kernel shell_history enabled"

"hello" <> " world" 连结字符串

脚本运行

elixir simple.exs

elixir --version

mix run

Vim Support:

git clone https://github.com/elixir-editors/vim-elixir.git ~/.vim_runtime/my_plugins/vim-elixir

Quote:

Instead of asking “how to do X in Elixir”, ask “how to solve Y in Elixir”.
In case things are not working as expected, please include as much information as you can in your report.

# 2 Basic type

integer, 1 0X1f
float, 1.0
boolean, true false
atom, :atom / symbol
string, "elixir"
[1,2,3] 'elixir', list
{1,2,3}, tuple

1.1 数值计算

默认是浮点计算

div rem 提供整数计算

div 2,3

rem(45,13)

支持 binary octal hexadecimal 数字
  0b1010
  0o777
  0x1F 0x1f

支持 浮点数科学表示

1.0e-10 , 64-bit double precision

round 得到最近的整数
trunc 得到整数部分

1.2 functions

Functions 包含函数名和函数参数个数 (参数类型 ?)

round/1 round/2

iex 显示帮助 h round/1; h +/2

1.3 Booleans

true false

is_boolean(true)
is_boolean(nil) false
is_nil(nil)

is_integer/1
is_float/1
is_number/1

1.4 Atoms

全小写，常量，值就是自己变量名。常用于表示操作状态 :ok, :error

true false 也是 atoms

is_atom(false) -> true
false == :false -> true

is_boolean(:false)

alias (别名)结构，首字母大写，是 atoms

例如 Hello 可用做模块名

is_atom(Erlang) -> true

1.5 Strings

double quotes 是 UTF-8 编码

支持字符串内插 变量写入字符串 "Hello #{:world}"

(Atom.to_string :world) == "world"

字符串内部可以使用 转义字符

IO.puts "Good\nLuck" -> :ok

Elixir 中的 Strings 在内部使用连续 binaries 表示的

is_binary("Hello") -> true

byte_size("Hello") -> 5

byte_size("hellö") -> 6

有 5 个字符，但占用 6 个字节大小。因为最后一个字符在 UTF-8 中用 2 bytes 表示

字符数 String.length("hellö")

方法来自 String 模块 操作 Unicode 字符

bit -> bitstring -> binary (8的倍数的 bitstring)

charlist 多用于和 Erlang 交互中

1.6 Anonymous Function

add = fn a, b -> a + b end

匿名函数

-> 左边是参数 右边是函数体 以 end 结尾

匿名函数保存在 add 中

调用函数 add.(4, 6) 需要用 .

区分 named function add/2 和匿名函数

named function 只能在 Modules 中定义

匿名函数内部的 变量赋值不影响外部环境

1.7 Lists (Linked)

a list of values, value 可以是任意类型

[1, 2, :ok, true]

列表长度 length

length [1, 2, :ok]

注意 list 是链表，计算长度需要遍历整个列表

合并列表 ++/2

从第一个列表中删除第二个列表中出现的元素 --/2

对 list 的操作不修改原始 list。添加或删除元素都会返回 新 list。

Elixir data structures are immutable.

no one will mutate data in memory - only transform it.

获取 list 的 head 和 tail

hd some_list

tl some_list

如果操作对象为 [] 则会报错

ArgumentError

有时候 list 会返回单引号值

原因在于当 Elixir 发现 list 中元素为可打印 ASCII 数字时，会将 list 当作 charlist 打印出来

iex 中 ?\v 可以查看对应的数字

charlist 在同 Erlang 代码交互时常见。

i 'hello' 可以查看 value 信息

单引号的是 charlists

双引号的是 字符串。二者不同。

1.8 Tuples

Elixr 用大括号表示 元组

元素可以是任意类型

{"Good", :ok}

tuple_size 元组大小

元组存放在连续内存中，通过索引或计算元组长度是快速操作。（随机访问

0-based 索引

获取元素

elem(tuple, 1)

修改元素

put_elem(tuple, 1, "New Element")

如果越界会报错，ArgumentError

1.9 Lists or tupels

List 是链表 linked list

合并列表取决于 left-hand 列表的长度

慢速操作 获取长度，按索引获取单个元素

Tuple 是连续内存。

获取长度和根据索引获取元素很快。更新和添加元素很慢，因为需要创建新的 Tuple

当你更新 tuple 时，除了被修改元素外，新旧元素是共享的。从而减少内存分配操作。

tuple 常用于从函数中返回额外信息，如操作成功与否。

大部分时候，Elixir 会指导你如何选择数据类型。

比如有访问 tuple 元素函数 elem 而没有对应的访问 list 元素的函数

计算数据结构元素个数的函数命名有一个简单的规则。

如果时间复杂度为常数时间。则命名为 size。如果是线性时间，则命名为 length (linear 和 length 都是 l 开头)

byte_size/1
tuple_size/1

length/1
String.length/1

Elixir 还提供 Port Reference PID

# 3 Basic operators

数值运算

+ - * / div/2 rem/2

列表操作符 ++/2 --/2

字符串连接 <>

布尔运算符

左右操作数必须是布尔值 true false

true and true (or and not)

false and raise("Error will never be raised")

and 对应 Erlang andalse

or 对应 Erlang orelse

|| && ! 操作数可以是任意类型

* 除 false nil 外的值都被求值为 true

nil && 13

比较 == != === <= >= < >

=== 在比较整数和浮点数时更严格

1 == 1.0 true

1 === 1.0 false

不同类型之间可以做比较

number < atom < reference < function < port < pid < tuple < map < list < bitstring

# 4 Pattern matching

操作符 = 在 Elixir 中实际是 匹配操作符

pin 操作符 ^ 可以用来获取变量绑定的值

1. match 操作符

x = 1

x
=> 1

2 = x 会导致 MatchError

1 = x 是有效表达式，因为左右的值相等

变量只能在 = 左侧才能被赋值

1 = unknown 中会被解释为试图调用 unknown/0 而这个函数不存在

CompilerError undefined function

2. 模式匹配

match 操作符不仅仅用于匹配简单数据，还能用于匹配更复杂的数据类型。

如 tuple

{a, b, c} = {:hello, "WORLD", 42}

如果无法匹配，则出现 MatchError

无法匹配的原因: 长度不同或类型不同，已有数据不匹配

{:ok, result} = {:ok, 13} 可以匹配

{:ok, result} = {:error, 13} 无法匹配 报错

可以匹配 List

[a,b,c] = [11,12,13]

匹配头部尾部

[head | tail] = [11,12,13]

(当然无法匹配 [] 空列表) 类似 hd/1 tl/1

添加列表头部

[0 | some_list]

Pattern matching allows developers to easily destructure data types such as tuples and lists.

destructure data types.

3. pin 操作符

Elixir 的变量可以 rebound Erlang 不允许 rebound

如果不希望变量被 rebound

可以使用 pin 操作符 ^

x = 1

^x = 2 (MatchError)

可以用于模式匹配中

{y, ^x} = {2, 1}

y => 2

当 x 很复杂时可以用 ^x 替代

{x, x} = {1, 2}

多次使用一个变量，这个变量必须指向一个值。

[head | _] = [1,2,3]

_ 允许忽略某个值

_ 特殊之处，无法读取其中的值

pattern matching 的 left side 不能是函数调用 function call

# 5 case, cond, and if

control flow structures

1. case

case {1, 2, 3} do
  {1, x, 3} ->
    "match, bind x to 2"
  _ ->
    "match forever"
end

匹配已有变量可以用 pin 操作符 ^x

case 分支(leg, case clause) 可以用过 guard 添加条件

  when x > 0

  guard 中的错误不会 leak 出来，只会导致 guard fail 即不满足条件

没有匹配的分支会报错

匿名函数允许有 多个分支和使用 guard

  但多个分支要求参数个数必须一致

2. cond

需要匹配不同值时使用

cond do
  2 + 2 == 5 ->
    "not true"
  2 * 2 == 3 ->
    "not true again"
  1 + 1 == 2 ->
    "true"
end

类似 imperative languages 中的 else if 语句

如果所有条件都返回 nil 或 false 会抛出错误 CondClauseError

最好总是提供 true -> "always true"

nil false 外的值都是 true

3. if 和 unless

if/2 unless/2 是 宏 macro

都支持 else block

if unless else 属于 Kernel 模块，这个模块定义的宏和函数都被自动导入

4. do/end 语法块 blocks

if true do
  1+2
end

可以写成

if true, do: 1+2

if false
  :this
else
  :that
end

写成

if false, do: :this, else: :that
  常规的语法 每个参数之间用 逗号 隔开

if %false% %do: :this% %else: :that%

if true do
  a = 1+2
  a + 10
end

是

if true, do: (
  a = 1+2
  b + 10
)

的简化

do/end 总是 bound to the outermost function call

  当 if condition 前有函数等时要注意

# 6 Binaries, strings, and charlists

string = "hello"
is_binary(string)

1. Unicode 和 CodePoints 码点

Unicode 给我们已知的字符进行了编码。每个字符被分配一个唯一数值索引

?a ?字符 可以获得 code point

大部分 Unicode code chart 用 十六进制表示 code point

a => 97 => 0061 => elixir 中表示 "\u0061"

"\u0061" === "a"

2. UTF-9 和 编码

code point 是 what we store, 计算机里存储的东西

encoding 是 how we store it, 计算机存储的方式

  一种机制，将 code point 数字转为 bytes

Elixir 使用 UTF-8，即 codde points 被编码成一系列 8-bit 的 bytes

UTF-8 是变长编码，使用 1 - 4 字节存储每个 codepoint

除了定义字符， UTF-8 还提供了 graphemes notion，即将多个字符显示为一个。

é 可以表示为一个字符，也可以表示为两个字符的组合

string = "hełło"

String.length 和 byte_size 不同

第一个计算 graphemes 第二个计算 raw bytes

Elixir 中查看 inner binary 的技巧

"aaa" <> <<0>>

或者用 IO.inspect("aaa", binaries: :as_binaries)

3. Bitstrings

bitstring 是 Elixir 的基础类型 <<1,2,3>>

bitstring 是内存中连续的比特

默认情况使用 8bits 1byte 来存储 bitstring 中的每个数字，但是可以通过

::n ::size(n) 来人为指定

<<3::4>> <<3::size(4)>>

十进制 5
二进制形式是 0101

超出可存储范围的数值会被截取掉

  <<1::8>> === <<257::8>>

4. Binaries

binary 基于 bitstring, bitstring 中 bit 数量能被 8 整除的叫 binary

every binary is a bitstring

not every bitstring is a binary

is_bitstring/1 is_binary/1

binary / bitstring 中可以使用 pattern match 模式匹配

<<0, 1, x>> = <<0, 1, 2>>

不使用 0:: 时默认每个实体匹配 1 byte 8 bits

匹配未知长度的 binary 可以用 ::binary

<<0,1,x::binary>>=<<0,1,2,3>>

:: 后边的是 modifier 其他 modifier 有

::binary-size(n) 匹配 n bytes 的 binary

string 是 UTF-9 编码的 binary 即 << >> 可能是 string

every string is a binary

not every binary is a valid string

String.valid?/1 判断是否为 String

因此字符串连接符 <> 实际为 binary 连接符

string 中也可以用模式匹配

<<head, rest::binary>> = 'usa'

需要注意 string 的模式匹配是针对 bytes 的而不是 chars

一个 char 可能占用多个 bytes

当在 string 中用模式匹配是，要加上 utf8 modifier

<<x::utf8, rest:binary>> = "über"

5. Charlists

charlists 是 intergers 列表，每个 integers 都是合法 code points

'hello' charlists

is_list 'hello'

List.first 'hello'

iex 默认输出 0-127 code point 的字符形式，超出范围的只输出 整数

改变这种行为需要用

IO.inspect('hello', charlists: :as_lists)

charlist to string

to_string/1

to_charlist/1

这两个函数也用于 integer atom 等

charlist 是 list 因此连接符号是 ++

# 7 Keyword lists and maps

两种主要的 associative data structure: keyword lists 和 maps

1. Keyword lists

a list fo 2-item tuples 并且第一个元素是 atom 被成为 keyword list

atom 是 key

list = [{:a, 1}, {:b, 2}]

简写为 [a: 1, b: 2]

keyword list 也是 list 支持所有 list 操作

list ++ [c: 3]

list[:a] 会返回第一个 a 对应的值

keyword lists 特性

  keys 是 atoms
  有序的，开发者指定
  可以有多个同样的key

if false, do: :this, else: :that

if( false, [do: :this, else: :that] )

if( false, [{:do, :this}, {:else, :that}] )

由此可见，如果 keyword list 是 函数/宏 的最后一个参数，则可以省略 [] 中括号

keyword lists 中可以用 模式匹配，但实际中很少使用。因为必须要求数量和顺序一致。

Elixir 提供 keyword 模块来操作 keyword lists

keyword lists 是 list，因此找 key ，计算长度等是线性操作。

在 Elixir 中常用于 传递 optional 值

如果需要存储大量值，并要求 key value 最多一一对应，应该使用 map

guarantee one-key associates with at maximum one-value

2. Maps

store key-value

map = %{:a => 1, 2 => :b}

  允许任何值作为 key

  key 是无序的

very useful with pattern matching 总是可以匹配到 subset

%{} 匹配任意 map

%{:a => a} = %{:a => 1, 2 => :b}

变量可以用于获取 匹配(pin) 添加 key

n = 1
map[n]
map = %{n => :one}
%{^n => :one} = %{1=>:one,2=>:two,3=>:three}

Map 模块提供方便操作 map 的函数

Map.get(map, :a)

Map.put(map, :c, 3)

Map.to_list(map)

更新 value:

%{ map | 2 => "two" }

不能更新不存在的 key

当key都是 atom 时，可以简写为 map = %{:a=>1,:b=>2}

map == %{a: 1, b: 2}

同时有新方法获取 value

map.a == 1

map.c (访问不存在的 key: KeyError)

尽量使用 map.field 语法和模式匹配来替代 Map 模块的方法

这种写法叫做 assertive style of programming (https://dashbit.co/blog/writing-assertive-code-with-elixir)

3. Nested data structures

开发中可能会用到 maps inside maps, keywords list inside maps 等。 Elixir 中有类似 put_in/2 update_in/2 等其他 macros 提供类似 imperative language 的函数，同时保证 immutable。

users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]

users[:john].age

users = put_in users[:john].age, 31

update_in/2 macro 类似 put_in 但是允许传入函数控制数据变化

users = update_in users[:mary].languages, fn languages -> List.delete(languages, "Clojure") end

其他还有

get_and_update_in/2 一次完成获取数据，更新数据

put_in/3

update_in/3

get_and_update_in/3 允许动态访问数据结构

# 8 Modules and Functions

多个函数可以被打包为模块 modules。我们已经使用过很多种模块，String

String.length("Erlang")

通常我们将模块写入文件 math.ex

使用 elixirc 编译到字节码文件 Elixir.Math.beam

在同样目录中启动 iex

用 Math.sum(1,2) 调用模块中函数

Elixir 项目习惯

  ebin 包含编译后字节码
  lib  包含 elixir 代码 .ex 文件
  test 包含测试 .exs 文件

实际项目中使用 mix build 工具

脚本模式 scripted mode，不会产生字节码

2. Scripted mode

Elixir 对待 .ex 和 .exs 文件流程大致相同，只是 .exs 文件不会被编译。但执行中，它们都被编译到内存中，只有 .ex 文件会保存字节码到硬盘 .beam 文件。

elixir math.exs

3. Named functions

在模块中，我们可以用 def/2 或 defp/2 定义公共或私有函数。

def/2 定义的函数可以在其他模块中调用，defp/2 定义的函数只能在模块内调用

函数定义支持 guards 和 多语句。当函数有多语句时，Elixir 会尝试每个语句直到找到匹配的函数签名 name/ariry。

zero? 这种形式表示函数返回 布尔值

类似 if 结构， named functions 支持 do: 和 do/end 语法

def zero?(0) do
  true
end

可以写做

def zero?(0), do: true

do: 单行

do/end 多行

4. 函数捕获 Function capturing

name/arity 可以用来指代特定函数，也可以用于表示函数类型 function type

Math.zero?(0)

fun = &Math.zero?/1

is_function(fun)

调用匿名函数 fun.(0)

(Erlang:

Fn = fun(X) -> X + 1 end.

函数调用 Fn(1).)

Elixir 中区分了 anonymous 函数和 named 函数，前者必须用 . 调用。

fun = fn x -> x + 1 end

shortcut:

fun = &(&1 + 1)

fun2 = &"Good #{&1}"

fun2.("morning")

&Module.function() 可以 capture 模块中的函数

fun = &List.flattern(&1, &2)

5. 默认参数 Default arguments

Named functions 支持默认参数

def join(a, b, sep \\ " ") do
  a <> sep <> b
end

任意表达式都可以作为 默认参数，但在定义函数时不会被求值。

函数调用是才求值

如果有默认参数的函数，有多条语句 multiple clauses。要求创建一个 函数头

def join(, b \\ nil, sep \\ " ")

使用默认参数要注意避免多语句之间互相覆盖

# 9 Recursion

1. 用递归实现循环 Loops through recursion

由于 immutability Elixir 和任何 functional programming language 中 loops 和 imperative languages 不同。 类似 C 的语言中循环是

for(i=0; i< sizeof(array);i++) {
  array[i] = array[i] * 2;
}

Elixir 中依赖 recursion 实现循环

递归调用函数，直到达成某个条件停止递归

No data is mutated in this process

持续递归调用直到满足 base case

2. reduce 和 map

利用递归求和

[], accu 作为 base case, 当list中为空时，求得的值保存在 accu 中

递归和尾调用优化是 Elixir 重要部分，常用来实现 loop

Enum 模块已经提供了很多方便的方法

Enum.reduce([1,2,3], 0, fn(x, acc) -> x + acc end)

Enum.map([1,2,3], fn(x) -> x * 2 end)

简写为

Enum.reduce([1,2,3], 0, &+/2)

Enum.map([1,2,3], &(&1 * 2))

# 10 Enumerables and stream

Elixir 中有 enumerables 概念，并且提供了 Enum 模块来处理它们

Enum.map(%{1=>2, 3=>4}, fn {k, v} -> k * v end)

模块中有大量函数用于 transform sort group filter 和 retrieve items from enumerables

也提供了 ranges

Enum.map(1..3, fn x -> x * 2 end)

不过这些函数都限于 枚举 数据结构中的值。如果要添加，更新元素，需要用特定数据结构模块提供的函数。

如 List.insert_at/3

Enum 模块的函数是 多态 的 polymorphic。因为它们可以用于多种数据结构，只需要这种结构实现 Enumerable 协议。（协议，接口）

2. Eager vs Lazy

Enum 模块中函数都是 eager 函数 （即时求值）。很多函数要求传入 enumerable 返回 list

当用 Enum 中函数进行多步计算时，每次函数调用都会产生中间 list

如

1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(add?) |> Enum.sum

3. pipe 操作符 |>

|> 符号，将 left side 表达式的输出作为 right side 函数的第一个参数

可以 highlight 被转换的数据

4. Streams

Elixir 提供 Stream 模块作为 Enum 的 lazy 操作备选。

1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum

Streams are lazy, composable enumerables

streams 构建一系列计算，只有将 stream 传入 Enum 模块函数是才被调用。

Stream 适用于 large, possibly infinite, collections

Stream 模块函数，参数为 任意 enumerable 返回值为 stream

也有创建 stream 的函数。如 Stream.cycle/1 根据参数创建无限循环 stream

Stream.unfold

def unfold(next_acc, next_fun)

@spec unfold(acc(), (acc() -> {element(), acc()} | nil)) ::
        Enumerable.t()

Emits a sequence of values for the given accumulator.

Successive values are generated by calling next_fun with the previous
accumulator and it must return a tuple with the current value and next
accumulator. The enumeration finishes if it returns nil.

Stream.resource/3 用于资源封装，保证资源正常打开和关闭。

Fiel.stream!/1 是基于 Stream.resource 的

stream = File.stream!("path/to/file")

Enum.take(stream, 10) fetch 前 10 行

streams 可以用于处理大文件和网络资源

一般优先使用 Enum 函数，当需要 laziness 操作时使用 Stream

# 11 Process

Elixir 中，代码都是在 processes 中运行的。Processes 之间互相隔离 isolated，并发运行，并通过 message passing 通信。

Processes 仅仅是 Elixir concurrency 的基础，但它们也提供了 build distributed 和 fault-tolerant programs 的方法。

Elixir Processes 不是操作系统进程。Elixir 中的 Processes 很 lightweight，甚至比有些语言中的线程更轻量。

因此很容易同时运行，tens or even hundreds of thousands of processes

1. spawn

启动新 processes 方法是用自动导入的 spawn/1 函数

spawn fn -> 1 + 2 end

spawn 的参数是在新建 process 中运行的函数

spawn 的返回值是 PID (process identifier)

被启动的进程会运行函数并在运行完毕后退出

Process.alive?(pid) 查看进程是否退出

self() 获取当前所在 process pid

2. send 和 receive

用 send/2 发送 messages 用 receive/1 接收 messages

当 message 被发送到 process，它被存放在 process mailbox。

receive/1 遍历当前 process mailbox 寻找能匹配给定模式的 message。

receive/1 支持 guards (when is_integer?(x)) 和 多语句。

发消息的 process 不会在 send/2 处阻塞，它将消息放在接收方 mailbox 中，就继续运行其他代码。process 可以给自己发送 messages。

mailbox 没有消息时，当前 process 会等待匹配消息到达。可以指定等待超时时间。

receive do
  {:hello, msg} -> msg
after
  1_000 -> "time out"
end

超时可以设置为 0。。。

inspect/1 可以将数据结构内部表示形式转为 string

flush/0 清空并打印 mailbox 中全部信息

3. Links

大多数时候我们以 linked processes 形式启动 process。没有 link 的 process 中出错时，process 打印 log，父进程继续运行。进程间是隔离，互不影响的。如果想让一个进程的错误传播到另一个进程，就需要将它们关联 link 起来。

spawn_link fn -> raise "oops" end

parent process 会接收到另一个进程的 EXIT signal

https://hexdocs.pm/elixir/Process.html

手动 link: Process.link/1

Creates a link between the calling process and the given item (process or port).

Links are bidirectional. Linked processes can be unlinked by using unlink/1.

通常将进程和 supervisors link，当 process 挂掉会原地创建新 process。

在 Elixir 中，失败的 process 可以期待被 supervisors 正确重启。"Failing fast" 是写 Elixir 程序的常见理念。

4. Tasks

大部分时候我们不会直接用 spawn/1 spawn_link/1 这么底层的函数，而是使用基于它们的抽象。例如 Task

Task 提供 better error reports 和 intropection (内省信息)

Task.start fn -> raise "task oops" end

Task.start/1 和 Task.start_link/1 返回 {:ok, pid} 而不仅是 pid。方便用于 supervision trees。

Task 还有 Task.async/1 Task.await/1 以及实现分布式的函数。

5. State

如果你的应用需要状态来保存配置，保存解析的文件，应该保存在哪呢？

Processes 是最常用的地方。我们可以写很多 loop infinitely 的进程来维护状态，收发消息。

defmodule KV do
end

iex kv.exs 可以加载 exs 中的模块

任何知道 pid 值的进程，都能给它发送 message

还可以给 pid 注册 name，根据 name 发送消息

Process.register(pid, :kv)

send :kv, {:get, :hello, self()}

使用 process 存储 state 及注册名字是很常见的模式。但大部分时候我们不会手动实现，而是用 Elixir 提供的很多抽象来实现，例如 agent 模块，就是 state 的抽象

{:ok, pid} = Agent.start_link(fn -> %{} end)

Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)

Agent.get(pid, fn map -> Map.get(map, :hello) end)

Agent.start_link 参数 name 可以自动注册名字。

除了 Agent，还有实现 generic servers 的 GenServer 等

将会在 Mix 和 OTP 指南中介绍。

# 12 IO 和 file system

简单介绍 input/output 机制和 file-system-related 功能，涉及模块 IO File Path。

1. IO 模块

reading writing to 标准输入输出 :stdio :stderr，files 和其他 IO 设备。

IO.puts("output")

IO.gets("input your name")

IO 模块默认从标准输入读，写入到标准输出。

可以用 :stderr 作为参数改变这一行为

IO.puts(:stderr, "Output to standard error")

2. File 模块

读取文件。默认以 binary 模式打开，使用 IO.binread/2 和 IO.binwrite/2 来读写。

可以指定用 :utf8 打开

File.read(path/to/file) utf8 编码

File 还提供很多 file system 相关函数

  File.rm/1
  File.mkdir/1
  File.mkdir_p/1
  File.cp_r/2
  File.rm_rf/1

变体 带 trailing bang (!)

  File.read!/1

  只返回文件内容，不返回 tuple，如果出错会抛出错误。

  没有 ! 的函数以模式匹配形式处理错误。

  如果你预期文件存在，要避免写 {:ok, body} = File.read(file)

  因为如果出错，错误信息将是 匹配错误，而不是文件不存在。如果不想处理错误，就使用 File.read!/1

3. Path 模块

File 模块以 paths 为参数。paths 是普通的 binaries。Path 模块提供处理 path 的函数。

Path.join("foo", "bar")

Path.expand("~/hello")

4. Processes

File.open/2 返回 tuple {:ok, pid}

File.open/2 返回 process，当你写入 file 时，实际是向 process 发送消息

IO.write(file, "content")

IO 模块需要特定的结果

用 process 代替 IO 设备，Erlang VM 允许 IO 消息在不同节点间传递，甚至跨节点交换文件。

5. iodata 和 chardata

IO 和 File 也允许使用 charlists 作为参数，也允许混用 charlists integers binaries

IO.puts(['hello', ?\s, "-world"])

list 可能表示 a bunch of bytes 或 a bunch of characters，取决于 IO 设备编码。

如果是未指定编码打开的文件，必须使用 IO 中 bin* 开头的函数。这些函数以 iodata 为参数，即 a list of integers 或 binaries

如果设备是 :stdio 或 utf8 编码文件，则使用其他函数。它们以 char_data 为参数，即 a list of characters 或 strings

Although this is a subtle difference, you only need to worry about these details if you intend to pass lists to those functions

# 13. alias, require, import

facilitate software reuse:

提供代码重用机制：

三种 directives: alias require import (都是 lexical scope)

一个 macro: use (allow used module to inject code)

alias Foo.Bar, as: Bar

  为模块创建别名

require Foo

  require 模块，使用其中的 macros

import Foo

  import 模块中的函数，可以省去 Foo. 前缀

use Foo

  调用 Foo 中定义的 custom code，作为 extension point

1. alias

alias Math.List, as: List

会覆盖默认的 List 模块

默认 List 模块指的是 Elixir.List 但是 Elixir 默认可以忽略。

覆盖后，仍然可以通过 Elixir.List 使用原 List 模块

alias Math.List 等价于 alias Math.List, as: List

alias 是 lexically scoped 意味着可以为不同的函数，不同作用域单独设置 alias

2. require

Elixir 提供 macros 作为 meta-programming 机制。Macros 在 compile time 展开

默认 public 函数可以直接通过模块使用，但 macros 需要 require 模块后使用

require Integer

Integer.is_odd(3)

Integer.is_odd/1 is defined as a macro so that it can be used as a guard

因为 is_odd 是宏，所以可以用于 guard

也是 lexically scoped。

3. import

可以省略模块名来使用其中的 public functions 和 macros

import List, only: [duplicate: 2] -> 引入 List.duplicate/2

除了 only 还有 :except

也是 lexically scoped。

4. use

use 会调用模块的 __using__/1 回调

use OtherModule, option: :value

编译为

require OtherModule
OtherModule.__using__(option: :value)

use allows any code to run, we can’t really know the side-effects of using a module without reading its documentation

推荐优先使用 import alias。

5. 理解 alias

首字母大写的 identifier，编译期转为 atom

String alias 转为 :"Elixir.String"

alias/2 改变 alias 展开成的 atom

alias 转为 atoms 是因为在 Erlang VM 中，模块以 atom 形式表示

例如调用 Erlang 函数

:lists.flattern([1,[2],3])

6. 嵌套 Module

defmodule Foo do
  defmodule Bar do
  end
end

与

defmodule Elixir.Foo do
  defmodule Elixir.Foo.Bar do
  end

  alias Elixir.Foo.Bar, as: Bar
end

一样

Bar 移出 Foo 后必须通过 Foo.Bar 访问

定义 Foo.Bar 前不需要定义 Foo 模块

alias 也保证 marcors 是 hygienic 的

7. 引入多个模块

Elixir v1.2 后，可以一次 alias import require 多个模块

alias MyApp.{Foo, Bar, Baz}

# 14. Module attributes

1. 作为注释 注解 As annotations

information to be used by user or VM

@vsn 被用作 code reload 机制，检查模块是否要更新

如果没有 @vsn，就以模块函数 MD5 作为 version

常用 attributes

  @moduledoc

  @doc

  @behaviour 指定 OTP 或自定义 behaviour

  @before_compile

Elixir 中 documentation 是 first-class 的，提供很多访问文档的函数

@moduledoc """

support Markdown

"""

elixirc module.ex 编译后才有文档

iex

h ModuleName 访问 @moduledoc

ExDoc 工具可以生成 HTML 格式

更多支持的 attributes: https://hexdocs.pm/elixir/Module.html#module-module-attributes

2. 作为 常量

让值更 visible 和 reuseable

@initial_state

与 Erlang 不同，用户定义的 attribute 只在 compilation time 存在。

通过调用 Module.register_attribute/3 使 attribute 行为类似 Erlang

访问为定义的 attribute 会引发 warning

每次读取 attribute，会获得它的当前值 snapshot，值在编译期读取而不是 runtime。这也使得 attribute 能用作 模块编译期 storage

正常情况下，重复赋值 attribute 会导致值变化。但你可以配置 attribute 累积值到 list

@param :foo
@param :bar
# @param == [:bar, :foo]

attribute 中可以调用函数（除本模块定义函数，因为本模块函数还未编译）

attribute name 和 value 之间不能换行

3. 作为临时存储 temporary storage

ExUnit

use ExUnit.Case, async: true

Next: structs / protocols / exception handling / sigils / comprehensions

# 15. Structs

map = %{a: 1, b: 2}

map[:a]

%{map | a: 3} => %{a: 3, b: 2}

structs 是扩展 map 的数据结构，提供 compile-time 检查和默认值。

1. structs 定义

要声明 struct 需要使用 defstruct

defstruct 参数为 keyword list 因此获取 value 可以用 . 操作符 john.name

struct 的名字为所在模块的名字

如果在另一个文件内定义 struct 在 iex 中需要通过

c("file.ex") 或 c("file.exs") 引入

defmodule User do
  defstruct name: "John", age: 27
end

compile-time guarantees 指的是只有通过 defstruct 定义的 fileds / keys 才允许出现在 struct 中

%User{oops: :field}

2. 获取 更新 structs

使用 key 为 atom 的 map 中 dot 操作符

john = %User{}
john.age

更新使用 map 语法

%{ john | name: "James" }

不能给 struct 添加新 key。这些 maps 可以共享 key structure in memory。

Struct 可以用于 pattern matching。

%User{name: name} = john
name => "John"

3. structs 底层实现是 maps

structs 底层是 有固定 fields 的 maps

structs 中有一个特殊的 fields __struct__，包含 struct 的 name

is_map(john) => true

john.__struct__

所谓 bare maps，是说 maps 中实现的 protocols 都不能在 struct 中使用

例如，无法遍历 struct 或 通过 key 获取 value

但是由于 struct 还是 map，可以使用 map 自己的方法

jane = Map.put(%User{}, :name, "Jane")

Map.merge

Map.keys

struct 自己的 protocols 提供重要特性 data polymorphism 数据多态。

4. structs 默认值和必需 key

如果你不指定默认值，默认值为 nil

defstruct [:name, age: 27]

混合使用不指定默认值参数和指定默认值参数时，要将不指定默认值参数放前边

顺序错误会引发 SyntaxError

@enforce_keys [:make] 指定必需有值的 field

# 16. Protocols

Protocols 是 Elixir 中实现多态 polymorphism 的机制。根据数据类型，有不同的行为。

多态可以通过 pattern matching 和 guard 实现

def type(value) when is_binary(value), do: "string"
def type(value) when is_integer(value), do: "integer"

为每个类型实现 type/1 函数，问题在于不好扩展 extend its functionality。

protocols 允许我们实现初始类型的函数。protocol 可以分发函数到实现 protocol 的任意数据类型。protocol 可以被任意类型在任意时刻实现。

定义 protocol

defprotocol Utility do
  @spec type(t) :: String.t()
  def type(value)
end

实现 protocol

defimpl Utility, for: BitString do
  def type(_value), do: "string"
end

调用 protocol 函数，类似模块

Utility.type(1000)

常用的 protocl 是 String.Chars 实现 to_string/1 函数会通知 Elixir Kernel 如何展示 custom structs

1. Example

描述元素个数 length size

length 表示需要通过计算才知道的数量，需要遍历 list

而 tupel_size byte_size 不需要计算 pre-computed

为不同数据类型实现通用 Size protocol

2. Protocols and structs

使用 struct 时，protocols 会更强大

struct 基于 map，但没有实现 map 的 protocol，比如 MapSet 是 struct

需要为 MapSet 实现 Size protocol : MapSet.size/1

利用 struct 可以实现更 robust 的数据结构，如 queues

defmodule User do
  defstruct [:name, :age]
end

defimpl Size, for: User do
  def size(_), do: 3
end

3. Implementing Any

为每种类型都实现 protocol 很麻烦。 Elixir 提供一些参数

可以指定某个类型自动继承 protocol 实现

可以自动为每个类型都实现 protocol

3.1 Deriving

defimpl Size, for: Any do
  def size(_), do: 0
end

defmodule Other do
  @derive [Size]
  defstruct [:name, :age]
end

指定继承 Size protocol，会使用 Any 对应的实现

3.2 Fallback to Any

另一种方式是在 protocol 中设置 fallback 为 Any

即在未找到对应类型的实现时，使用 Any 的实现

通常未找到实现要抛出 protocol is not implemented 错误

Elixir 开发者喜欢 explicit 胜过 implicit 因此多用 derive

4. Built-in protocols

Enum 模块针对实现 Enumerable protocol 的数据结构

String.Chars protocol

inspect 函数基于 Inspect protocol

  the protocol used to transform any data structure into a readable textual representation.

  IEx 就是用这个函数来显示结果的。

当 inspect 结果以 # 开头时，表示显示的信息可能有丢失

# 17. Comprehensions

经常会遇到要遍历 可迭代对象 Enumerable 的情况，比如 过滤出需要的数据，或者转为另一个 list (map)。 列表解析是执行这样操作的语法糖。

使用 for special form

for n <- [1,2,3], do: n * n

comprehension 由三部分组成 generators filters collectables

对比 Erlang: [N * N || N <- [1,2,3]].

1. Generators, filters

n <- [1,2,3,4] 是 generator

<- 的右侧可以是任意 Enumerable

例如 Range: for n <- 1..4, do: n * n

<- 左侧支持模式匹配

generators 后 do 前可以加入 filter，

comprehensions 会过滤掉所有使 filter 求值为 false / nil 的值

comprehensions 提供了等价于 Enum Stream 模块方法的更简洁表示形式

它还支持多重 generator 和 filter

for dir <- dirs,
    file <- File.ls!(dir),
    path = Path.join(dir, file),
    File.regular?(path) do
  File.stat!(path).size
end

多个 generators

for i <- [:a, :b, :c], j <- [1,2], do: {i,j}

comprehensions 内的赋值不影响外部

2. Bitstring generators

对 bitstring streams 使用列表解析

pixels = <<213, 45 ... >>

for <<r::8, g::8, b::8 <- pixels>>, do {r, g, b}

对比 Erlang: RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].

可以和普通 comprehension 一起用，同样支持 filter

In Elixir, the word string means a UTF-8 binary and there is a String module that works on such data. Elixir also expects your source files to be UTF-8 encoded.

On the other hand, string in Erlang refers to char lists and there is a :string module that works mostly with both char lists and UTF-8 encoded binaries.

Elixir also supports multiline strings (also called heredocs)

Erlang

is_list('Hello').        %=> false
is_list("Hello").        %=> true
is_binary(<<"Hello">>).  %=> true

Elixir

is_list 'Hello'          #=> true
is_binary "Hello"        #=> true
is_binary <<"Hello">>    #=> true
<<"Hello">> === "Hello"  #=> true

3. :into option

以上结果都是 list，但也可以插入到不同数据结构中

:into 选项

:into 支持实现 Collectable 的类型: String Sets Maps Stream

for <<c <- " remove all spaces ">>, c != ?\s, into: "", do: <<c>>

常用于插入 map

for {key, val} <- %{"a" => 1, "b" => 2}, into: %{}, do: {key, val * val}

例如 stream

stream = IO.stream(:stdio, :line)
for line <- stream, into: stream do
  String.upcase(line) <> "\n"
end

(hit Ctrl+C twice to exit IEx)

# 18. Sigils

Elixir 提供 double-quoted strings 和 single-quoted char lists

这仅仅是部分 textual representation

例如 Atoms 使用 :atom 形式表示

sigils 是处理 textual representations 的一种方法

以 tilde 符号 ~ 开头紧跟着一个字母 (用于识别 sigil) 然后是分隔符 delimiter。尾部分隔符后可以有 modifiers。

regex = ~r/foo|bar/

1. 正则 Regular expression

第一个常用的 sigil 是 ~r 用于创建正则表达式

regex = ~r/foo|bar/

Elixir 支持 Perl-compatible 正则

"foo" =~ regex 用于测试是否匹配

regex 支持 i modifier 表示正则 case insensitive

Regex 模块中有其他支持的 modifier

分隔符不仅可以用 / sigil 支持 8 种符号

/foo/
|foo|
"foo"
'foo'
(foo)
[foo]
{foo}
<foo>

这样就可以简化 ~r/^https?:\/\// 为

~r(^https?://)

2. Strings, char lists, word lists sigils

Elixir 内置其他三种 sigils

表示 Strings

~s 等价 ""

  避免转义双引号

表示 char lists

~c 等价 ''

  避免转义单引号

表示 word lists

~w 表示词列表，按照空格分隔

  支持 modifier: c s a 表示分隔后结果为 char list, strings, atoms

3. Interpolation and escaping in string sigils

在 string sigils 中内插值和转义字符

一些 sigil 变体处理变量内插和转义

  sigil 识别字母的大写形式，不处理 变量内插和转义

转义
  \a - bell/alert
  \b - backspace
  \d - delete
  \e - escape
  \f - form feed
  \n - newline
  \r - carriage return
  \s - space
  \t - tab
  \v - vertical tab
  \0 - null byte
  \xDD - \x13 表示单个 byte (hexadecimal)
  \uDDD \u{D...} - 表示单个 Unicode codepoint (hexadecimal) \u{1F600}

Sigil 支持 heredocs

~s'''

'''

~s"""

"""

主要用于写文档

~S"""
    iex> convert("\"foo\"")
    "'foo'
"""

4. Calendar sigils

处理 times dates 的 sigils

- Date

%Date{} struct 包含 year month day calendar 属性 可以用 ~D sigil 创建

d = ~D[2020-08-24]

d.day

- Time

%Time{} 包含 hour minute second microsecond calendar 用 ~T 创建

~T[23:03:06.0]

t.second

- NaiveDateTime

%NaiveDateTime{} 包行 Date 和 Time 的 fields 用 ~N 创建

~N[2020-10-31 23:09:09]

不包含 timezone

- DateTime

%DateTime{} 比 NaiveDateTime 多了 timezone 用 ~U 创建

~N[2020-10-31 23:09:09Z]

%DateTime{minute: minute, time_zone: time_zone} = dt

time_zone

5. 自定义 sigils

Elixir 的 sigils 是 extensible 的

使用 ~r/foo/i 相当于调用 sigil_r(<<"foo">>, 'i')

其中 modifier 为 char list ( 'i' == [?i]  )

<<"foo">> == "foo"

通过 h sigil_r 可以查看详细信息

自定义 sigil 只需要实现 sigil_{identifier} 函数即可

modifier 类似 [?n]

sigils 可以在 compile-time 完成，这样可以在 run-time 跳过编译的步骤。这需要利用macro 完成。

https://hexdocs.pm/elixir/Regex.html

处理其他时区:

  https://hexdocs.pm/tzdata/readme.html
  https://hexdocs.pm/elixir/DateTime.html

# 19. try catch and rescue

Elixir 有三种错误处理机制。 errors throws exits

1. errors

errors 或者叫 exceptions 用于代码出出现 exceptional 时

例如 :foo + 1 ArithmeticError

runtime error 可以用 raise/1 抛出 参数为 message

  error 类型为 RuntimeError

其他异常可以用 raise/2 抛出，参数为 error name 和 keyword list

  message 用于显示错误内容

  raise ArgumentError, message: "invalid argument foo"

自定义 error 定义模块，并使用 defexception 构造器。这样就会创建和模块名一致的 error

defmodule SomeError do
  defexception message: "error message"
end

异常可以通过 try/rescue 结构恢复

try do
  raise "oops"
rescue
  e in RuntimeError -> e
  # 如果处理 error
  RuntimeError -> "Error!"
end

实际开发中，Elixir 开发者很少使用 try/rescue 结构。

大部分语言在无法打开文件时，强制要求 rescue 代码。但 Elixir 提供 File.read/1 函数，返回 tuple 来表示是否成功打开文件，通过模式匹配选择要执行的行为。

Elixir 中避免使用 try/rescue 因为不将 error 用于流程控制。如果的确要用于流程控制，需要用 throws。

2. throws

值可以被 thrown 并在稍后 caught。 当必须使用 throw/catch 才能获取值时，采用 throw / catch。

这种情景很少，例如使用未提供恰当 API 的 libraries 时。

假设 Enum 模块没有提供找到一个符合要求值的方法时

try do
  Enum.each -50..50, fn(x) ->
    if rem(x, 13) == 0, do: throw(x)
  end
  "Got nothing"
catch
  x -> "Got #{x}"
end

使用 Enum 提供的 API

  Enum.find -50..50, &(rem(&1, 13) == 0)

3. exits

Elixir 代码都在 processes 中运行。当 process 自然终止时，例如未处理的异常，它会发送 exit 信号。process 可以明确发送 exit 信号来终止自己

spawn_link fn -> exit(1) end

exit 信号可以通过 try/catch 捕获，但这种情况很少见

exit 信号是 fault tolerant 系统的重要组成部分。

Processes usually run under supervision trees which are themselves processes that listen to exit signals from the supervised processes. Once an exit signal is received, the supervision strategy kicks in and the supervised process is restarted.

4. after

确保资源正常 cleaned up

try do
  raise ""
after
  File.close(file)
end

如果是 linked process 退出，after 没有机会执行。但 file process 总是和当前 process linked，当前进程 crash 后 file 总会被关闭，这是独立于 after 的。

这一特性也适用于 ETS tables，sockets，ports 等

当函数内只有 try 结构时，可以省略 try ，需要指定 after rescue catch 中的一个

5. else

try 结构中不发生 throw 或 error 时执行，

在多个子句中使用模式匹配，如果没有匹配则 raise 错误，这个错误无法被当前结构捕获

6. variables scope

try catch rescue after 结构中的变量，无法作用于外部环境

只能将 try 结构赋值给外部变量

这些内容很少用到，只有对付 没有遵守 Elixir 规则的库时会用到。

# 20. Typespecs and behaviours

1. Types 和 specs

Elixir 是动态类型语言，所有 Elixir 类型是在 runtime 检查的。

但 Elixir 自带 typespecs，提供类型注释，用于

  声明带类型函数签名 函数签名又叫 specifications

  声明自定义类型

1.1 函数类型 Function specification

Elixir 提供很多内置类型 integer pid，可以用于函数签名。

例如 round/1 函数签名 round(number()) :: integer()

:: 左侧是函数和输入，右侧是输出

类型可能省略括号 parentheses

代码中函数签名写在 @spec 属性后，紧挨着函数定义前，可以描述 public 和 private 函数。spec 函数名和定义函数名必须一致。

Elixir 支持组合类型 [integer] 或 maps

1.2 定义自定义类型

通过 @type 可以自定义类型，帮助解释代码含义，增加可读性

@type year :: integer

@typedoc 是 type 的文档 类似 @doc @moduledoc

例如定义组合类型

@type error_map :: %{
  message: String.t, 使用 String.t 而不是 string
  line_number: integer
}

使用 Struct 可以达到类似效果

自定义类型可以在其他模块中使用，默认是 exported 的

  ModuleName.type_name

@typep 可以让类型 private，也会影响 ExDoc 生成的文档

还是要在计算时抛出错误，而不是根据类型直接抛出类型错误

1.3 静态代码分析 Static code anylysis

类似 Erlang 工具 Dialyzer 可以利用 typespecs 进行静态分析

2. Behaviours

规定一些模块必须实现的某些公共函数，从而使这些模块共享 public API

例如 Plug，每个 plug 都是至少实现 init/1 和 call/2 的模块

Behaviours 可以

  定义模块必须实现的一组函数

  确保模块实现了规定的函数

可以将 behaviours 类比 interfaces in Java

2.1 定义 behaviours

假定实现一组 parser

有 JSON parser，MessagePack parser

每个 parser 都提供 parse/1 extensions/0 函数

parse/1 返回结构数据的 Elixir 表示

extensions/0 返回这个 parser 支持的 file extensions 列表

Parser behaviour

defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]
end

Elixir 中 term 代指 any type

2.2 应用 behaviours

在实现模块中

@behaviour Parser

函数前使用 @impl

@impl Parser
def parse(str), do: {:ok, "Json Parser " <> str}

@impl Parser
def extensions, do : ["json"]

如果有 callbacks 没有实现, 或函数名错误，会产生 compile-time 错误

函数签名实现错误，无法发现。

2.3 动态分发 Dynamic dispatch

在 behaviour 声明模块中可以动态调用对应的实现

# 21. Debugging

一些 debug code 的方法

1. IO.inspect/2

IO.inspect(item, opts \\ [])

强大在于，它不影响原有代码的运行逻辑，仅仅显示中间状态

IO.inspect 可以有 label 参数，用于标记输出

IO.inspect binding() 可以返回全部的变量和值

2. IEx.pry/0 IEx.break!/2

IO.inspect/2 是静态的，Elixir 的交互终端提供更多动态 debug 方法

第一个是 IEx.pry/0 替代 IO.inspect binding()

代码需要在 iex session 中运行

代码暂停执行，使用 continue 恢复执行

在项目内运行 iex 使用 iex -S mix TASK

缺点在于也要修改原始代码

IEx 提供 break!/2 允许设置，管理 断点

break!/2 无法访问 aliases 和 imports，因为它是在 compiled artifact 上工作，而不是 source code

3. Debugger

Erlang/OTP 提供的图形化 debugger 工具

iex

c "example.ex"

:debugger.start()

:int.ni(Example)

  必须保证编译生成 Elixir.ModuleName.beam 文件

  准备 module 用于 debugging

:int.break(Example, 3) 设置断点

Example.double_sum(1,2)

4. Observer

debug 复杂系统

需要理解整个 virtual machine, processes, applications, 设置 tracing mechanisms

:observer.start() 启动 observer

这会启动一个图形界面，提供很多面板帮助理解 runtime 和 project。

5. 其他工具

:crashdump_viewer 查看 crash dumps

Linux Trace Toolkit, DTRACE, SystemTap

Microstate accounting

Mix 的 profile (cprof fprof)

社区工具

  wObserver : observer 的 Web 界面

  visualixir : 开发阶段 process message visualizer

  erlyberly : 开发过程中用于 tracing 的 GUI

# 22. Erlang libraries

Elixir 可以同 Erlang 很好地交互。Elixir 可以直接使用 Erlang 库。

http://erlang.org/doc/apps/stdlib/index.html

1. binary 模块

处理非 UTF-8 编码模块，不返回 Unicode codepoints 返回 raw data bytes

String.to_charlist "Ø"

:binary.bin_to_list "Ø"

2. 格式化输出

Elixir 没有类似 printf 的函数。 Erlang 有 :io.format/2 和 :io_lib.format/2

前者输出到 terminal output，后者输出为 iolist

:io.format("Pi : ~10.3f~n", [:math.pi])

to_string :io_lib.format("Pi : ~10.3f~n", [:math.pi])

Erlang 中要注意对 Unicode 的处理

3. crypto 模块

有 hashing 函数，digital signatures，encryption 等

Base.encode16(:crypto.hash(:sha256, "Elixir"))

:crypto 并非标准库之一，但包含在发行版中。要使用 :crypto 需要加入到 application extra_application 列表中

def application do
  [extra_application: [:crypto]]
end

4. digraph 模块

处理 directed graphs，寻找最短路径，或环

:digraph 原地修改 grpah 结构，因为用 ETS table 实现的

5. Erlang Term Storage

:ets :dets 分别处理在内存和硬盘上保存的大型数据结构

ETS 创建包含 tuples 的表。默认是 Protected，即只有创建表的 process 可以写入，其他 process 可以读出。

ETS 的函数可以让我们把 ETS 当作数据库，key-value 存储或缓存使用

:ets 中函数副作用 side-effect 是修改 table 状态

6. math 模块 :math

:math.pi
:math.sin
:math.exp
:math.log

7. queue 模块

:queue 实现 双向 FIFO 先进先出队列

8. rand 模块

:rand.uniform()

:rand.uniform(6)

9. zip zlib 模块

:zip 读写 ZIP 文件，获取文件信息

计算 zip 文件中文件个数

:zip.foldl(fn _,_,_, acc -> acc + 1 end, 0, :binary.bin_to_list("file.zip"))

:zlib 处理 zlib 格式数据压缩

compressed = :zlib.compress(String.t)

byte_size compressed

:zlib.uncompress(bytes)

MIX AND OTP

# 1. Mix

创建一个完整的 Elixir application，拥有 supervision tree, configuration, tests 等

elixir -v

要创建一个 distributed key-value store。

保存 key-value 对，并分布到多个 nodes

包含一个简单的 client 支持命令

CREATE shopping (table name / key name)

PUT shopping milk 1

PUT shopping eggs 3

GET shopping mil

DELETE shopping eggs

使用三种工具

  OTP Open Telecom Platform

  Mix Elixir 构建工具。提供任务来完成 create compile test 管理依赖等

  ExUnit Elixir 单元测试框架

1. 第一个项目

mix new kv --module KV

  --module 让 mix 创建模块 KV 而不是默认的 Kv

2. 项目编译

mix.exs 文件是配置项目的地方

两个 public 函数

  project 项目配置，如项目名，项目版本

  application 用于生成 application 文件

deps private 函数

  在 project 中调用，定义项目依赖

在项目根目录

mix compile

生成 application manifest 名为 kv.app，位于 _build 下 _build/dev/lib/kv/ebin

在项目中启动 iex session

iex -S mix

在 iex 中可以用 recompile 重新编译 (有变动返回 :ok，无变动返回 :noop)

3. 运行测试

mix 生成基本测试

测试文件命名 <filename>_test.exs

test/kv_test.exs 对应 lib/kv.ex

test/kv/bucket_test.exs 对应 lib/kv/bucket.ex

  测试是 exs 文件，因为不需要编译

  测试模块叫 KVTest 用 use ExUnit.Case 插入 testing API

  引入的宏 doctest : doctest KV 表示 KV 中有 doctests

  用 test 宏定义测试

test/test_helper.exs 用于设置 test 框架

基本测试执行 mix test (重新编译源代码，生成 application manifest)

执行单个测试 test/kv_test.exs

4. 自动格式化代码

mix format

diff test/kv_test.exs test/kv_test_backup

mix format --check-formatted

mix help format

5. 环境

mix 默认支持三种环境

:dev mix 任务默认执行环境

:test

:prod

这些都是针对当前项目的。我们添加的依赖默认在 :prod 环境

在 project 函数中可以通过 Mix.env 获取项目环境

start_permanent: Mix.env == :prod

  start_permanent 为 true 时，当应用 supervision tree shuts down，VM 会 crash。因此只在 :prod 中设为 true

修改 mix 环境 MIX_ENV=prod mix compile

6. Exploring

mix help

mix help TASK: mix help compile

# 2. Agent

学习保存以及如何在多个 entities 间分享 state

可能考虑用 globally shared variables，但我们会学不一样的方法。

1. 状态带来的问题

Elixir 是 immutable language, nothing is shared by default。

如果想分享信息，多个地方可以读及修改数据，我们有两个选择

  使用 processes 并传递 message

  ETS

当使用 processes 时，很少用自己从头实现，可以使用 Elixir 和 OTP 提供的一些抽象:

  Agent - 简单的状态封装

  GenServer - Generic servers processes 封装状态，提供同步和异步调用，支持代码更新等

  Task - 异步计算单元，允许创建 process，并在稍后获得结果

以上都是基于 process，并通过基本的 send receive spawn link 实现。

先使用 Agent

2. Agents

如果 process 就是用来保存状态，agents 很适合

启动 iex: iex -S mix

Agent.start_link 匿名函数 （初始化状态）

Agent.update(agent, fn current_state -> new_state end)

Agent.get(agent, fn current_state -> state end)

Agent.stop(agent)

可以任意修改 agent 内容。

将 Agent 相关操作封装在模块 KV.Bucket 中

先写点测试

use ExUnit.Case 导入 test 相关宏如 docset/1 test/2

async: true 多个测试并行执行 run in parallel 用于加速测试

  只在测试之间不相互依赖，或不修改全局值时启用

  如果需要写入文件系统或访问数据库，一般保持 synchronous (取消 :async 选项)

实现 start_link/0 get/2 put/3

mix test 通过

3. Test setup with ExUnit callbacks

ExUnit callbacks 所有的 KV.Bucket 测试都需要启动 bucket agent。

ExUnit 支持 callbacks

setup do
  # 启动 bucket
end

setup/1 宏定义 callback，在每个测试运行前执行

  非共用 agent，而是测试前自动启动 agent

test context

test "test info", test_context do
end

4. Other agent actions

Agent.get_and_update + Map.pop 实现 delete/2 (bucket, key)

5. Client/Server agents

类似 delete 这样的函数运行在 agent process 中，这个 process 就是 server。

其他发生在这些函数外的都是 client。

如果有耗时操作要执行，你需要考虑在 client 还是 server 上执行。

如果在 server 上执行，那么它就无法响应其他请求，会造成其他 client 超时。

GenServer 中会更清晰地划分 client server

# 3. GenServer

(用 GenServer 构建 registry)

每个 bucket 有自己的 pid，可以注册为 具名 process

Agent.start_link(fn -> %{} end, name: :shopping)

命名为 :shopping

不过，用 atom 命名动态进程不好，因为我们要把用户输入的 bucket name 转为 atom，而永远不应该将用户输入转为 atom。atom 没有回收机制。

用户输入可能超出内存限制。当然，实际会先达到 Erlang VM 对 atom 数量的限制，然后系统会挂掉。

因此我们需要创建自己的 process registry。关联 bucket name 和 bucket process。

registry 需要能保证 always up to date。例如有 bucket crash 后，registry 需要避免提供旧数据，即 registry 需要 monitor 每个 bucket 进程。

registry 需要能接收处理 ad-hoc message，Agent API 不够用了。

用 GenServer 创建 registry process，monitor bucket processes。

在 Elixir 和 OTP 中，GenServer 提供工业级功能来构建 server。

1. GenServer callbacks

GenServer 是在特定条件下，调用有限函数的 process。

在 Agent 中，client 和 server 是在一起的

def put(bucket, key, value) do
  # client code
  Agent.update(bucket, fn state ->
    Map.put(state, key, value)
  end)
end

GenServer 里，上边的代码划分为

# Client code
def put(bucket, key, value) do
  GenServer.call(bucket, {:put, key, value})
end

# Server code
def handle_call({:put, key, value}, _from, state) do
  {:reply, :ok, Map.put(state, key, value)}
end

可以向 GenServer 发送两种请求

calls 和 casts

calls 是同步请求，server 必须返回响应，client 在 server 处理请求时处于 waiting 状态。

casts 是异步请求，server 不会返回响应，client 不需要等待 server 回复

这两种请求都是 sent 到服务器的消息，会按照顺序处理。

启动 GenServer:

{:ok, registry} = GenServer.start_link(KV.Registry, :ok)

  参数 :ok 对应 init/1 中的 :ok

异步调用 无返回值

GenServer.cast(registry, {:create, "shopping"})

同步调用 有返回值

{:ok, bk} = GenServer.call(registry, {:lookup, "shopping"})

2. The Client API

GenServer 的实现分两部分 client API 和 server callbacks

二者可以在一个模块，也可以分开在两个模块

client 是任意调用 client 函数的进程

server 是传递到 client 中的 process indentifier 或 process name

KV.Registry start_link/1 中 opts 可以指定 server process 的 name

Client 请求常写成 tuple 形式

GenServer 还有 callback 来保证 server 初始化，终止 server，处理请求。

  terminate/2

  code_change/3

目前用到的有 init/1 handle_call/3 handle_cast/2

3. Testing a GenServer

测试流程

  spawn server on a setup callback

setup 中使用 来自 ExUnit.Case 的 start_supervised!/2

确保下一个 test 启动前，关闭上一次 test 启动的 registry process

推荐都使用 start_supervised!/2

4. The need for monitoring

以上 GenServer 中的功能在 Agent 中也可以实现。下边的就无法在 Agent 中实现。

应对 bucket stops 或 crashes 的情况

先测试:

fail 被 Agent.stop(pid) 杀掉的进程还在 registry 中

为了解决这个问题，需要让 registry 能 monitor bucket processs，建立 monitor 后，bucket process 退出时会发 notification 到 registry

创建 bucket process
建立 monitor
杀掉 bucket process
显示接收的消息

iex(1)> {:ok, pid} = KV.Bucket.start_link([])
{:ok, #PID<0.156.0>}
iex(2)> Process.monitor(pid)
#Reference<0.2112787397.2546991106.12284>
iex(3)> Agent.stop(pid)
:ok
iex(4)> flush()
{:DOWN, #Reference<0.2112787397.2546991106.12284>, :process, #PID<0.156.0>,
 :normal}
:ok

Process.monitor 生成 unique reference 因此需要保存 ref 和 pid 对应关系

refs = %{}

5. call, cast or info

可以定义一个处理其他任意 unknown 消息的 handle_info/2 callback

handle_call/3 用于同步请求，等待 server 返回

handle_cast/2 用于异步，不保证消息送达，应当节俭使用

handle_info/2 处理其他不是由 call/2 cast/2 发出的 messages，比如普通的 send/2 发出的

如果未处理到达 handle_info/2 的 unexpected message，GenServer 会 crash。

而未处理的到达 handle_cast/2 handle_call/3 的消息，大概率是 a developer mistake

https://elixir-lang.org/cheatsheets/gen-server.pdf

6. Monitors or links

link 和 monitor 区别

  link 是双向的，一个 crash 另一个也 crash 除非是 trapping exist

    Agent crash: Agent.stop(pid, :bad)

    :normal 才返回 :ok 其他值 crash

    :reason 是 :normal, :shutdown or {:shutdown, _} 之外的值，error report will be logged

    https://hexdocs.pm/elixir/Agent.html#stop/3

  monitor 是单向的，被 monitor 的进程 crash，另一个仅接收到对应消息 crashes, exits 等

上边的 hadle_cast 里 同时 link 和 monitor 到 registry

这种实现里，registry 会和 bucket 一起 crash

正确方法是: 不 link registry 和 bucket，将 bucket link 到一种特殊的 process 上，这种 process 叫 Supervisors，被设计用来处理 failures 和 crashes。

# 4. Supervisor and Application

实现 KV.Registry 管理 buckets。KV.Registry mointors buckets 从而在 bucket 崩溃采取行动。这就引入一个问题，当执行失败时会发生什么？

没有监控，bucket crash 后 registry 的状态是错误状态。用户无法读写崩溃的 bucket，无法新建与崩溃 bucket 同名的 bucket。

加上监控，在 bucket 崩溃时就可以从 registry 中移除 bucket pid。

实践中我们不期待 processes 崩溃。但无论因为什么原因崩溃时，我们能确保系统依然正常工作。

也许会想，保证绝对不会出错就可以了。这种思路是 defensive programming。

运行中的系统有很多可能导致崩溃的原因，要处理全部的 errors，会浪费时间去处理错误而不是实现功能。

Elixir developer prefers to “let it crash” or “fail fast”.

从失败中恢复的常见方法就是 restart whatever part of the system crashed。

back to initial state，那个状态是一定能保证工作的

Elixir 中 restart 由 Supervisor 完成。

A Supervisor is a process that supervises other processes and restarts them whenever they crash

Supervisor 管理任意受监督 processes 的 life-cycle，如 启动，关闭。

接下来会监督 KV.Regisgry。创建 KV.Supervisor

Application，Mix 将全部代码打包成 application。了解如何定制 application 来保证 Supervisor 和 Registry 能够启动，运行。

1. 第一个 supervisor

监督进程三个功能
  启动 child processes
  restart child processes
    原因: 不正常关闭，特定条件
  关闭 child processes

Supervisor 定义类似 GenServer

strategy: :one_for_one 意味着 只重启挂掉的进程

supervisor 启动时，会遍历 children 列表，调用每个模块中的 child_spec/1 函数

child_spec/1 返回子进程设置，包括 如何启动进程，进程是 worker 还是 supervisor，进程是 temporary transient 还是 permanent 等

当 use Agent/GenServer/Supervisor 时，自动定义 child_spec/1

KV.Registry.child_spec([])

%{id: KV.Registry, start: {KV.Registry, :start_link, [[]]}}

supervisor 按定义顺序一个个启动子进程

  启动参数为 :start 里的内容

    如上则是 KV.Registry.start_link([])

{:ok, sup} = KV.Supervisor.start_link([])
Supervisor.which_children(sup) -> 显示子进程

supervisor 启动时，它的子进程也同时启动

[{_, registry, _, _}] = Supervisor.which_children(sup)

  获取 registry 进程

GenServer.call(registry, :bad_input)

  发送错误命令使 registry crash

Supervisor.which_children sup

  会发现 Registry 被重启了，pid 改变

现在 registry 被 supervisor 启动，而我们无法直接获取它的 pid。

必须询问 supervisor 才能得到，我们可以给进程起名作为 uniquely identified in a single machine，然后通过名字与进程交互。

alias 别名

require 必须 require 后才能用 macro

import 导入 函数或宏 支持 :only :except

use 基于 require 实现

2. 给 processes 命名

在 KV.Registry.start_link/1 中传入 :name

这样 supervisor 调用

  KV.Registry.start_link(name: KV.Registry) 启动进程

:name 参数是 locally named 意味着对所在 machine 可用

现在我们可以不用 PID 创建 bucket

{:ok, sup} = KV.Supervisor.start_link([])

KV.Registry.create(KV.Registry, "shopping")

之所以为 Registry 命名是因为只有这一个进程，bucket 的进程是基于用户输入内容创建的，如果基于用户输入命名进程，就会有很多无法被垃圾回收的 atom 存在，最终达到 VM 设置的上限。

现在 supervisor 可以启动 registry 了，但如何在运行项目时启动 supervisor 呢？这就需要 application

application -> supervisor -> children processes

3. 理解 application

到目前为止我们都在 application 中工作

每次修改代码，运行 mix compiler，都有 Generated kv app 信息

查看这个文件 _build/dev/lib/kv/ebin/kv.app

它包含 Erlang term。Erlang syntax

lib/kv 下有两个文件夹

  ebin 存放 Elixir artefact 如 .beam 和 .app

  priv 下存放所有其他文件

启动 applications

运行 iex -S mix (mix 编译并运行 :kv application)

Application.start(:kv) -> :error

iex -S mix run --no-start 仅编译不启动

Application.start(:kv) -> :ok

Application.stop :kv
Application.stop :logger

再次启动 :kv 时，{:error, {:not_started, :logger}}

  原因是 :kv 依赖 :logger

  可以使用 Application.ensure_all_started :kv

iex -S mix == iex -S mix run

4. application callback

自定义 applications 启动

mix.exs 中 application/1 里的 mod 指定 application callback module

mod: {KV, []}

mod 中的模块可以是任何实现 Application behaviour 的模块

实现 callback

  start/1

  还有 stop/1

配置自动启动两步

  1. 添加模块到 application mod 列表中

  2. 在 mod 中实现 start/1

application callback 就是用来启动 supervisor tree 的。有时 supervisor 也可以被 supervised

5. Project 还是 applications

mix 区分 projects 和 applications

即 mix.exs 中

我们的这个 mix project (KV.MixProject) 有一个 :kv application

也有不定义 application 的 project (lib?)

所谓 project 指一个 mix project

application 指 OTP Application

  started and stopped as a whole by the runtime

6. Next steps

ExUnit 的 start_supervised! 就启动了一个 supervisor

动态启动的 bucket 也需要有 supervisor

application -> supervisor -> registry

registry -> bucket (启动，但没 supervisor)

# 5. Dynamic supevisors

尽管我们已经有 supervisor 来监督 registry，但当 bucket 使 registry 崩溃时，我们还会丢失全部 registry 中的数据即 状态，就无法继续 lookup bucket processes 了。

我们希望 bucket 崩溃不影响 registry

写 bucket crash 测试

Agent.stop(bucket, :shutdown)

process 终止原因不是 :normal 时，所有关联 processes 会收到 EXIT 信号，这些 关联 processes 会终止，除非这个信号是 trapping exits

我们要使用新的 supervisor 来动态监督启动监督全部 bucket。这些 supervisor 的 children 是动态产生的。因此叫 DynamicSupervisor

每个 child 通过 DynamicSupervisor.start_child/2 启动。

DynamicSupervisor 一对多 KV.Bucket process

1. bucket supervisor

由于不知道 supervisor 的 child 信息，我们可以不用在新文件中定义 supervisor，不需要有 start_link 和 init 函数。

可以直接在 KV.Supervisor 下定义 DynamicSupervisor

目前，我们用模块名命名进程

:one_for_one 是目前唯一的 strategy

新的问题，当 bucket crash 后，它会被 supervisor 立即重启

但新重启的 bucket 并没有被加入到 registry 中，因此无法访问到

解决方案是 配置 KV.Bucket 中的 Agent 为 :temporary 的，

即 crash 后不再重启

设置之后，这个 supervisor 就无法重启子进程。那么这个 supervisor 意义何在呢？

supervisor 提供了正常 startup 和 shutdown 子进程的方法，尤其在 supervisor tree 中。

2. Supervision trees

supervisors that supervise other supervisors 形成 supervision tree

当添加 child 到 supervisor 时，需要注意 supervisor strategy

:one_for_one 保证 KV.Registry 在 KV.BucketSupervisor 前启动

而 KV.Registry 需要调用 KV.BucketSupervisor 来创建 Bucket，要求 KV.BucketSupervisor 在 KV.Registry 前启动。（两者冲突）

另外 如果 KV.Registry 挂掉，KV.Bucket 名字和进程对应信息都丢失，因此这种情况下 KV.BucketSupervisor 的 children processes 都要终止

另外可选的策略是 :one_for_all :rest_for_one

:rest_for_one 重启在 挂掉进程启动后 启动的进程

  我们希望在 KV.Registry 挂掉后，终止 KV.BucketSupervisor
  这就需要把 KV.Registry 放在 KV.BucketSupervisor 后，而这违反之前讨论的限制

:one_for_all 任意 child 挂掉，就重启所有 children

因此修改 KV.Supervisor

先启动 DynamicSupervisor / KV.BucketSupervisor，再启动 KV.Registry

Supervisor strategy :one_for_all

3. 在测试中共享状态

现在为了保证测试隔离性，每次测试前都新建 registry

但现在 registry 依赖全局注册的 KV.BucketSupervisor

只要我们仅依赖与共享状态中不共享的部分，就可以依赖共享状态。

当运行并行测试，并使用访问共享数据的函数时会出问题。

如果这里出现问题，可以每次测试前启动新的

  bucket supervisor

  将 bucket supervisor 作为参数传入 registry start_link 函数

  对应要修改 registry start_link 函数

4. Observer 工具

是时候介绍 Observer 了。

iex -S mix

:observer.start

Application 标签页需要切出去回来才能看到新选择应用的 示意图 ???

新创建一个 bucket

iex(2)> KV.Registry.create(KV.Registry, "shopping")

就会看到出现一个新的 child (切换下标签)

可以右键发送 kill signal

always start processes inside supervision trees, even if they are temporary, to ensure they are always reachable and introspectable.

使用 Observer 这样的工具可以看到

下一章介绍如何 speed things up

# 6. ETS

每次查询 bucket 都需要发送 message 到 registry。如果同时有很多查询，这里会成为瓶颈。 bottlenect !

(仅仅是 ETS 示例，不要将 ETS 用做永久 cache)

1. ETS 做缓存

ETS 存储任意 Elixir/Erlang term 到 in-memory table。

:ets 模块

创建 ETS table

  :ets.new
    :set 表示 key 不能重复
    :protected 表示只能创建 table 的进程写入，其他进程可以读出
    (:public 任意进程可以读写 :private 仅有创建进程可以读写)

    :named_table 表示给 table 进程命名为 table name，通过 table name 可以访问

让 KV.Registry 使用 ETS

KV.Registry.lookup/2 不请求 server 直接从 ETS 中读取，ETS 是在 processes 间共享的。

ETS table 默认只有 registry process 可写，其他进程可读

read_concurrency: true 优化并发读性能

有些测试会时好时坏，这是因为

  1. 过早优化，增加了 cache layer
  2. 应该使用 call/2 而不是 cast/2

2. Race conditions

用 Elixir 不会让代码逃离 race conditions

竞态条件

Elixir 默认不共享状态能让我们更容易摆脱它

测试出现问题的原因:
  在操作和观察到 ETS table 发生变化之间有 delay

我们期待的行为

  调用 KV.Registry.create(registry, "shopping")

  registry 创建 bucket ，更新 cache table

  访问 cache: KV.Registry.lookup(registry, "shopping")

  返回 {:ok, bucket}

但 KV.Registry.create/2 是一个 cast 异步操作，返回命令早于实际写入 cache

  (实际发生的一种情况可能是)

  调用 KV.Registry.create(registry, "shopping")

  访问 cache: KV.Registry.lookup(registry, "shopping")

  返回 {:error}

  registry 创建 bucket ，更新 cache table

(为何不适用 ETS 无影响？还是影响小到测不出来)

解决方案: 用 call/2 而不是 cast/2

Elixir 中更常用 call/2 而非 cast/2，call/2 能够提供 back-pressure: block until get a reply

在非必要时使用 cast/2 也是一种过度优化

mix test --trace

  当测试中有 deadlocking 或 race conditions 时，--trace option 可以让测试同步执行，async: true 参数无效

新错误和刚才解决的类似，删除 bucket 操作比查询操作晚执行。

刚才使用 call/2 替代 cast/2，但 handle_info/2 没有等价同步操作

解决方案之一是向 registry 发送同步请求

  Agent.stop/2 是同步请求，只有在 bucket process 终止后才返回。
  此时，:DOWN 消息也被 registry 接收到（但可能还未处理）

测试 exit 和 crash 时移除 pid 是为了确保 registry Process 正确处理 shutdown message。

KV.Regsitry.lookup/2 返回 valid bucket 不代表 bucket 还 alive

bucket 可能随时 crash

  test "bucket crash any time"

当数据可以被异步读取是，要注意 race condition 可能出现

实践中，如果你需要为 dynamic process 创建 registry，应该使用 Registry 模块。

提供类似 GenServer + :ets 的功能，又能同时并发处理读写。能在 40 核的机器上 scale。

# 7. Dependencies and umbrella projects

build TCP server 作为 kv 应用的 client。

break projects into smaller applications。不要创建 big monolithic 应用。

1. 外部依赖

在 mix.exs 的 deps 函数中列出外部依赖

def deps do
  [
    {:plug, "~> 1.0"}
  ]
end

~> 1.0 表示安装 1.x.x 版本

  https://hexdocs.pm/elixir/Version.html

Hex 上是 stable release，如果需要其他版本，可以提供 Git 链接

{:plug, git: "plug.git"}

mix.lock 加入版本管理，方便其他人使用和你一样版本的依赖

常用 mix deps 命令

mix deps.get

mix deps.update

mix deps.tree

mix help deps

2. 内部依赖

项目特定依赖。

Mix 支持 Git repositories 和 umbrella projects

Elixir 项目不鼓励对内部依赖使用 Git 形式。

Elixir 鼓励将项目分割到不同 applications。但管理很多 Git repositories 会很麻烦。因此 Mix 支持 雨伞应用。

Umbrella 项目用来构建在单个 repository 内的项目。

创建新 Mix 项目 kv_umbrella

kv_umbrella
  apps
    kv
    kv_server -> now kv

mix 可以用一个命令编译 apps 下的全部 applications

你也可以分别 build test deploy 它们。

3. Umbrella projects

mix new kv_umbrella --umbrella

umbrella 项目的 mix.exs project 中

有 apps_path: "apps" 而不是 app: :kv

这表示项目是 umbrella 项目

在 apps 中创建 kv_server

mix new kv_server --module KVServer --sup

这表示项目是 umbrella 项目

在 apps 中创建 kv_server

mix new kv_server --module KVServer --sup

这次 --sup 参数给 application 添加 supervisor tree

mix 自动设置了 build_path config_path deps_path lockfile

--sup 自动在 application 中增加 mod:

KVServer.Application 中直接定义 KVServer.Supervisor 而不是在新文件里定义

现在可以到 umbrella 下运行 mix test

kv_server 功能和 kv 一样，但不需要从头开发，可以直接将 kv 作为一个依赖引入。

4. 雨伞项目内依赖

修改 apps/kv_server 下的 mix.exs

defp deps do
  [{:kv, in_umbrella: true}]
end

这样 :kv_server 将 :kv 作为依赖，并在启动前启动 :kv application

将 kv 移动到 apps 下

还需要修改 kv mix.exs 中的 project/0 函数

添加 build_path config_path deps_path lockfile

5. 不要死板 Don’t drink the kool aid

Umbrella 基于 "mono-repo" 模式，将多个应用放在一个 repository 中。

Umbrella 通过提供简便的 compile test 和 run 操作优化了这个模式。

这个模式里，应用不是完全隔离的，它们共享同样的配置和依赖（版本）。

如果你的项目里几个应用需要使用同一个依赖的不同配置，或不同版本，那就超出 umbrella 的能力。

从 umbrella 拆成常规模式很容易。最差也可以仅仅移除 umbrella 相关配置，每个应用使用自己的配置文件，都还继续放在一个 repository 中。 （repository 是枷锁。。。）应用间依赖通过 :path （代替 :git）实现。

mix bump ?

6. 总结

Finally, keep in mind that applications in an umbrella project all share the same configurations and dependencies.

# 8. Task and gen_tcp

用 Erlang 的 :gen_tcp 模块处理请求。

1. Echo server

TCP server，随后会增加 supervisor 并处理多个连接。

server 需要
  监听端口
  等待客户端连接
  读取客户端请求，返回响应

lib/kv_server.ex

loop_acceptor/1 中的 loop_acceptor 无法被调用，但我们需要这行代码来完成 tail call。

测试 server

在 kv_server 中启动

iex -S mix

KVServer.accept(4040) 启动服务器

用 telnet 测试 telnet 127.0.0.1 4040

新 macOS 没有 telnet 可以用 nc (netcat) 替代

nc -v 127.0.0.1 4040

现在有一些bug，

  退出 telnet 或 nc 时 server 会因为 client 关闭连接 crash,

  server 因为其他原因 crash 了怎么办

2. Tasks

之前学了 agents，generic servers, supervisors 都用来处理多信息或多状态。

Task 模块提供仅运行任务的功能。

Task 的 start_link/1 函数接收匿名函数，并在新进程中运行它，新进程会是 supervisor tree 的一部分。

修改 lib/kv_server/application.ex 中 start/2

application 的 children 列表中，传入 two-element tuple

Supervisor 会调用 Task 的 start_link/1 函数

现在可以通过 PORT=4321 mix run --no-halt 运行服务器

启动多个 clients 发现第二个客户端不正常工作，这是因为处理请求的是同一个进程，而它已经接受第一个的请求，无法处理第二个。

3. Task supervisor

为了处理多个连接，可以在 acceptor 里启动其他进程处理新请求。

修改 loop_accepter/1

直接启动 Task.start_link/1 可能导致主进程随着新进程崩溃。

和 KV.Registry 中解决方案类似，不过现在可以使用 Task 自带的 supervisor

Task.Supervisor

child spec: {Task.Supervisor, name: KVServer.TaskSupervisor}

注意要先于 KVServer.accept/1 启动 KVServer.TaskSupervisor

在 loop_acceptor/1 中改写为:

{:ok, server_pid} = Task.Supervisor.start_child(
  KVServer.TaskSupervisor,
  fn -> server(client) end
)

语法有点冗长，如何能写成

{:ok, server_pid} = KVServer.TaskSupervisor.start_child(
  fn -> server(client) end
)

:get_tcp.controlling_process(client, server_pid) 将 client 的 controlling_process 设置为 server_pid，默认是执行 :gen_tcp.accept/1 的进程，即主进程。

看看 supervisor tree 中的 restart 策略是否合适。

Task 默认 :restart 策略是 :temporary

对于处理请求的 task，这一策略合理。

对于 accept 部分，希望在 crash 后还能重启

  因此需要设置 restart: :permanent

  解决方法一，单独写自己的 Task 模块，替换 Task

    {CustomTask, fn -> KVServer.accept(port)}

  方法二，多用于定制别人写的 agents tasks servers。使用 Supervisor.child_spec/2，第一个参数为 child_spec tuple，第二个是 keyword list options

    Supervisor.child_spec({Task, fn -> KVServer.accept(port) end}, restart: :permanent)

    Supervisor.child_spec 支持从 module/tuple 创建 child spec，并支持覆写 child spec 选项。

Now we have an always running acceptor that starts temporary task processes under an always running task supervisor.

# 9. Doctests, patterns and with

解析之前提到的命令

CREATE
PUT
GET
DELETE

然后将命令分发到 :kv application

1. Doctests

Elixir 里 documentation is first-class citizen

文档可以通过

mix help 或 h Enum 获取

流程: 实现功能，写文档，保证文档和 doctests 一致

创建 command parser

  lib/kv_server/command.ex

Doctest

iex> 前有 4 格空格

多行用 ...> 代表换行继续

预期结果在 iex> 或 ...> 之后，到 换行或 iex> 截止

@doc ~S"""""" 阻止 \r\n 被转义

对应测试 test/kv_server/command_test.exs

执行 doctests

use ExUnit.Case, async: true
doctest KVServer.Command

执行一个 app 下的测试

mix cmd --app kv_server mix test --color

--color 带颜色输出

mix.exs 中的 aliases 函数可以简化命令
def project do
  [
    aliases: aliases,
  ]
end

defp aliases do
  [
    child_app_test: "cmd --app child mix test --color"
  ]
end

https://elixirschool.com/blog/til-umbrella-app-child-app-tests/ TIL How to Run Tests for One Child App in an Umbrella · Elixir School

继续实现功能.

doctest 是按照空行区分测试的，一个空行表示一个测试结束，移除空行会合并两个测试为一个

doctest 是先写文档后测试，目的不是取代 tests 而是保证文档和代码同步

2. with

解析命令后可以执行命令运行逻辑了。

stub definition

def run(command) do
end

实现具体逻辑前，先让 kv_server 使用 parse/1 run/1。

现在 kv_server 中的 read_line/1 还会在关闭客户端时 crash。先修复这个问题。

pipe 操作符用于处理单个数据流，但代码中有多个嵌套数据流时，可以使用 with 简化代码。

with {:ok, data} <- read_line(),

特别当匹配失败时，会跳过剩余代码直接返回 不匹配的值。

将嵌套的 case 转为 with

3. Running commands

实现 KVServer.Command.run/1，执行 :kv application 的 API

第一个 bodiless 无函数体的函数头，声明有默认参数的多分支函数

def run(command)

补上测试

KVServer.Command.run/1 直接发送命令到名为 KV.Registry 的 server，这是由 :kv application 注册的。

这个 server 是全局的，即如果同时两个测试发送消息，测试之间会冲突。需要决定是写互相隔离 的单元测试，还是写使用全局状态 global state 的集成测试 integration tests

目前只写了单元测试，每次只测试一个模块。但是为了把 KVServer.Command.run/1 作为单元进行测试，需要改变实现，不直接发送命令到 KV.Registry 而是传入 server 作为参数

run/1 改写为

def run(command, pid) do
  KV.Registry.create(pid, bucket)
  {:ok, "OK\r\n"}
end

这样可以在测试中启动新的 KV.Registry 实例，并传入 run/2

现在写基于全局状态的 integration tests

即测试从 TCP server 到 bucket 的整个流程。

集成测试依赖 global state 必须是同步的 synchronous.

可以测出应用中组件如何一起工作，代价是测试性能。

集成测试是测试主要流程的，避免测试边界条件。

test/kv_server_test.exs 集成测试 使用 TCP client 发送命令到 server，断言得到希望的返回值。

defmodule KVServerTest do
end

集成测试依赖 global state 所以不加 async: true 选项

为保持状态干净，每次测试前重启 :kv application

停止 :kv 会打印 warning，

使用 :capture_log 避免打印 log 信息

每个测试前加 @tag :capture_log 或在 testcase 上加

@moduletag :capture_log

测试有可能进入超时。

需要基于 code quality, confidence, test suite runtime 选择合适的测试策略。

例如开始只进行集成测试，在项目变复杂时引入单元测试。

# 10. Distributed tasks and tags

回到 :kv 添加 routing layer，这会根据 bucket 名字把请求分布到多个 Nodes 上

routing layer 中有 node 列表

[
  {?a..?m, :"num1@computer-name"},
  {?n..?z, :"num2@computer-name"}
]

根据匹配情况，将请求分发到对应 Node 上执行。

没有匹配会报错。

1) 确保 ./erlang.cookie 值一致
2) 保证 epmd 运行 epmd -d 显示 debug info

1. first distributed code

在分布式环境中，继续使用同样的 processes，message passing， receiving message 概念。

Elixir processes 是 location transparent 的。即在发送消息时，不考虑接收方是在同一个 node 还是在不同 node。VM 在两种情况下都能传递消息。

用不同名字启动 VM 即启动不同的 node。

在同一网络下使用 short name: iex --sname foo

不同网络下使用 long name: iex --name foo@ip-or-domain-address

在一个 node vm (node2) 中定义一个模块 Hello

iex(node2@mbp)1> defmodule Hello do
...(node2@mbp)1> def world, do: IO.puts "hello world"
...(node2@mbp)1> end

启动 node1 vm:

运行 Hello.world -> UndefinedFunctionError

但 node1 可以在 node2 上 spawn 执行这个函数

Node.spawn_link :"node2@mbp", fn -> Hello.world end

结果 node2 上进程的 pid，运行函数，并将结果返回给 node1

pid = Node.spawn_link :"node2@mbp", fn ->
  receive do
    {:ping, client} -> send client, :pong
  end
end

send pid, {:ping, self}

用 flush 查看接收到的返回值

可以看出我们可以用 spawn_link 在其他 node 启动进程。

但基于已有知识，要避免在 supervison trees 外启动进程。

可选的改进方法有

  - :rpc 模块

    :rpc.call(:"foo@computer-name", Hello, :world, [])

  - 如果另一个 node 上有 server (GenServer) 运行，可以通过 GenServer.call({name, node}, arg) 或将远端 GenServer 作为第一个参数传入

  - 可以用 Task 模块

这些方法有不同的特性。 :rpc 和 GenServer 会将请求序列化到服务器，task 仅仅异步执行，只序列化 supervisor 启动 task 部分。

在 routing layer 中会使用 task

2. async/await

对于需要获取返回值的 task 提供 async/await 模式

task = Task.async(fn -> do_something() end)
res = do_otherthing()
res + Task.await(task)

在 supervision tree 内启动:

Task.Supervisor.async/2 替代 Task.Supervisor.start_child/2

然后用 Task.await 接收结果

3. distributed tasks

在 :kv 中增加 KV.RouterTasks 到 lib/kv/supervisor.ex init/1

$ iex --sname foo -S mix

$ iex --sname bar -S mix

在一个 node 上启动另一个 node 的 task

task = Task.Supervisor.async {KV.RouterTasks, :"node1@mbp"}, fn -> {:ok, node} end

node 类似 self 返回 node name

这里我们的参数是 anonymous function，分布式情况最好用 module, function, arguments (MFA)

task = Task.Supervisor.async {KV.RouterTasks, :"foo@mbp"}, Kernel, :node, []

通过 Task.await(task) 获取结果

anonymouse 要求目标 node 和 caller 代码版本完全一致

4. routing layer

lib/kv/router.ex

String.valid? <<23,24,125::3>>
false

String.valid? <<23,24,125::8>>
true

增加 test: test/kv/router_test.exs

运行测试的前提是启动两个 node

在 apps/kv 中运行

iex --sname bar -S mix

执行测试 elixir --sname foo -S mix test

5. test filters and tags

测试变得更复杂了。分布式相关的测试需要启动两个 node 无法和普通模块一同测试。

ExUnit 有一些 tag 来执行特定 callbacks 或用来过滤测试。

@tag :distributed 等价于 @tag distributed: true
test "" do

添加标签后，可以检查 node 是否 alive

如果不 alive，就从测试代码中 exclude 全部分布式相关测试

修改 test/test_helper.exs

exclude =
  if Node.alive?, do: [], else: [distributed: true]

这样常规的 mix test 运行时会跳过 标记为 distributed 的测试

要运行 disributed 测试需要用

  elixir --sname foo -S mix test

同时要保证 bar@computer-name 节点可用

mix test 可以动态 include exclude 测试

mix test --include distributed
mix test --exclude distributed
mix test --only distributed

6. wiring it all up

route layer 已经可用。修改 KVServer 使用 router 分发请求

替换 KVServer.Command 中的 lookup/2

server interaction 测试要使用 routing table，而测试失败

添加 distributed tag

注意添加了tag的测试，会较少被测到。因为预备步骤较多。

其他可选解决方案是在 test/test_helper.exs 中启动 distributed node。

Erlang/OTP 提供这样的 API，但这里不再涉及。

还有一个选择是，让 routing table 可配置。即在特定测试下，改变 routing table。 缺点是会使得特定测试不再异步，需要谨慎使用。

Routing table 还是 hard-code，需要改进。

每个 node 上运行一个 registry

# 11. Configuration and releases

让 routing table 可配置，并打包到生产环境

1. application environment

配置不仅是针对 dev/test/prod 环境，还为不同模块配置不同的 entries in the routing table。

OTP 提供的 application environment 正是做这个的。

每个应用都用 key 保存特定配置。

:kv application environment

def application do
  [
    ...,
    env: [routing_table: []],
    ...,
  ]
end

application 中适合提供 empty table，实际运行根据所处环境获取

Application.fetch_env!(:kv, :routing_table)

将根据 config 中的配置决定环境参数

2. configuration

入口位于 config/config.exs

配置文件在 build time 读取 compile-time

例如配置 iex

config :iex, default_prompt: ">>>"

简单起见，可以设置 :routing_table 为 [{?a..?z, node()}]

即请求都由一个 node 处理，这样可以移除 test/kv_server_test.exs 中的 distributed tag

但 KV.RouterTest 还是需要有两个 node

这可以通过在测试启动前修改 environment 实现

KV.RouterTest 中

在所有测试前执行

setup_all do
  ...
end

测试步骤

1) iex --sname bar -S mix

2) 新终端 elixir --sname foo -S mix test --include distributed

3. release

为了打包到生产环境，Elixir 提供 releases

release 是 self-contained directory，由

  application code
  all of its dependencies
  whole Erlang Virtual Machine
  runtime

组成

release assembled 后，可以打包并部署到与 assemble release 环境相同的操作系统上。

Once a release is assembled, it can be packaged and deployed to a target as long as the target runs on the same operating system (OS) distribution and version as the machine that assembled the release.

普通项目可以直接 mix release

对于 umbrella 项目需要额外输入

  由于 umbrella 项目的应用可以一起部署也可以分别部署

在 def project 中配置

releases: [],

此外还要为 prod 环境配置 routing_table

if Mix.env() == :prod do
  ...
end

配置有个问题是，我们无法预知部署服务器的 computer-name

这可以在 config/release.exs 文件中解决，release.exs 会在生产环境运行，

让开发者有机会设置正确的 node name

  runtime configuration : config/releases.exs

assembling release:

  MIX_ENV=prod mix release deploy_both

release 位于 _build/prod/rel/<release_name>/bin/<release_name>

一些提示

Release created at _build/prod/rel/deploy_both!

    # To start your system
    _build/prod/rel/deploy_both/bin/deploy_both start

Once the release is running:

    # To connect to it remotely
    _build/prod/rel/deploy_both/bin/deploy_both remote

    # To stop it gracefully (you may also send SIGINT/SIGTERM)
    _build/prod/rel/deploy_both/bin/deploy_both stop

To list all commands:

    _build/prod/rel/deploy_both/bin/deploy_both

(Docker-like)

bin/release_name start
bin/release_name start_iex
bin/release_name restart
bin/release_name stop

bin/release_name rpc COMMAND
bin/release_name remote
  在运行系统中执行命令或连接到运行系统

bin/release_name eval COMMAND
  启动新 system 执行命令，然后关闭

bin/release_name daemon
bin/release_name daemon_iex
  作为 daemon 启动系统

bin/release_name install
  在 Windows 上作为 service 安装

release 启动的 shortname 和 release_name 一致

# 设置 shorname bin/release --sname start

4. why release

release 好处: precompile package 全部代码和运行时为一个单元

  Code preloading
    VM 开发环境是在 interactive mode 下，按需加载模块。这样如果生产环境用这个模式，首次响应时会因为要加载大量模块而拖慢响应时间。releases 中 VM 运行在 embedded 模式下，提前载入全部可用模块，启动后可以立即响应请求

  配置和自定义
    开发者可以自由控制系统配置和 VM flags 来启动系统

  self-contained
    不需要部署服务器预先有代码或 Erlang/Elixir。release 中只包含用到的 Erlang/Elixir 标准库。

  多版本 release
    每个应用可以在不同配置下 release

5. assembling multiple release

启动 release

_build/prod/rel/<release_name>/bin/<release_name> start

测试 Key Value Store 命令: ❌

配置 release: foo bar

6. configuring release

Release 提供内置 hooks 来满足几乎各种配置需求

config/config.exs: build-time application configuration

  经常根据环境导入其他配置文件

config/releases.exs: runtime application configuration

  release boots 时运行，可以通过 config providers 扩展 (k8s)

rel/vm.args.eex
  template file，复制到每个 release 中，提供对 Erlang VM 及其他 runtime flags 的静态配置

rel/env.sh.eex rel/env.bat.eex
  模板文件，复制到每个 release。在 set up 环境变量时运行，环境变量包括针对 VM 的和 general environment 的。

- 操作系统环境配置

每个 release 包含环境文件，env.sh (Unix-like) env.bat (Windows)

在 Elixir system 启动前执行。

在这个文件里可以运行 OS-level 代码，如调用其他应用，设置环境变量，有些变量可以设置 release 如何启动自己。

例如生产环境中，我们需要动态设置 --name 参数

可以通过设置 RELEASE_DISTRIBUTION 达到目的

Mix 预置了模板，通过

  mix release.init 复制到 application 中

  * creating rel/vm.args.eex
  * creating rel/env.sh.eex
  * creating rel/env.bat.eex

取消最后两行注释

- runtime 配置

另一个常见需求是: 在 release 运行时计算配置

例如从 disk 或其他服务 读取 routing_table

这可以在 config/releases.exs 中完成

如配置 KVServer 的 port

import Config
config :kv_server, :port, System.fetch_env!("PORT")

为何不用 System.get_env/2

7. summing up

完成了一个简单的 key-value store.

类似 Riak，Riak 不同在于

  buckets 是复制备份的，

  使用 consistent hashing 代替 router
    consistent hashing, 帮助减少在增加节点后需要迁移的数据

Embedded systems, data-processing and data-ingestion, web applications, streaming systems, and others are many of the different domains Elixir excels at.

Happy coding!

META-PROGRAMMING in ELIXIR

# 1. Quote and unquote

介绍 meta-programming 技术。

用 Elixir 数据结构，表示 Elixir 程序的能力

1. Quoting

Elixir 程序的内部表示形式是 three-elements-tuple 三元素元组

sum(1, 2, 3) -> {:sum, [], [1, 2, 3]}

使用 quote 宏可以得到任意表达式的内部形式

quote do: sum(1, 2, 3)

第一个: 函数名

第二个: metadata

第三个: arguments list 参数列表

更复杂的结构也会表示为类似的 tuple 嵌套格式，形成树状。

其他语言称之为 Abstract Syntax Tree (AST)

Elixir 称为 quoted expressions

从 quoted expressions 得到 textual 表示形式 (textual code representation)

  Macro.to_string(quote do: sum(1,2+3,4))

quoted expressons 通用表示形式

{atom | tuple, list, list | atom}

第一项是 atom 或其他同样形式的三元元组

第二项是 包含 metadata 的 keyword list

第三项是 函数调用的参数列表，或 atom。如果是 atom，表示这个元组代表变量

有五种字面量，quoted expressions 和 textual code representation 一致

:sum (Atoms)
1.0 (Numbers)
[1,2] (Lists)
"strings" (Strings)
{key, value} (二元元组)

2. Unquoting

quote 是为了获得代码特殊部分的内部形式。

有时需要将某些代码添加到内部表示形式

例如将变量插入到 quoted expression，用实际值替代形参

Macro.to_string(quote do: 11 + number)

此时需要在 quote 内部使用 unquote

Macro.to_string(quote do: 11 + unquote(number))

要将 list 插入 list 需要用 unquote_splicing

  用 unquote 会将整体插入，而不是元素

  unquote_splicing 参数为 list with quoted expressions

inner = [1,2,3]

# Macro.to_string(quote do: [31,32,unquote(inner),100])

Macro.to_string(quote do: [31,32,unquote_splicing(inner),100])


写宏时，需要从其他代码中获取代码或插入代码，从而在编译期生成代码

3. Escaping

Elixir 中只有部分形式是有效 quoted expressions

例如 map 不是有效 quoted expression，四元元组也不是，但可以表示为 quoted expression

quote do: %{1 => 2}

{:%{}, [], [{1,2}]}

escape 也是为了添加代码到 quoted expressions，

unquote 添加 valid quoted expression，

escape 将 invalid quoted expression 转为 valid

Macro.escape(%{hello: :world})

inner = %{"three" => 3}

Macro.to_string(quote do: [31,32,unquote(inner |> Macro.escape),100])

Macros receive quoted expressions and must return quoted expressions.

regular Elixir value 和 quoted expression 区别:

integers atoms strings 等，quoted expression，textual code representation 一样

maps 等，需要用 Macro.escape 转为 quoted expression

函数或引用等，无法转为 quoted expression

example: 例如 map = %{a: 100, b: 200}

> quote do: map
{:map, [], Elixir}

> quote do: unquote(map)
%{a: 100, b: 200} -> invalid quoted expression

> quote do: unquote(map |> Macro.escape)
{:%{}, [], [a: 100, b: 200]}

这才和 quote do: %{a: 100, b: 200} 的结果一致

# 2. Macros

1. Foreword

Elixir 尽量为 macros 提供安全环境。

但开发者有责任写出干净代码。macros 比普通 Elixir 代码难写，在不该用宏的地方使用宏是不好的代码风格。

宏应当是最后的选择。

explicit is better than implicit.

clear code is better than concise code.

2. first macro

Elixir 里的宏用 defmacro 定义

macro 接收 quoted expression，返回 quoted expression

函数版本会比宏版本的 unless 多打印一行。

原因是函数求值前，会先对所有参数求值

宏不会，它只是单纯地将一种 quoted-expression 转为另一种

Macro.expand_once/2 将 quoted expression 根据当前环境展开，

这一过程中，expanded/invoked Unless.macro_unless/2 返回其结果

随后将结果转为 string 就是原代码展开后的代码

可以定义任意函数和宏，除了那些不是 Elixir 实现的特殊形式 Kernel.SpecialForms

3. Macro hygiene

quote 内定义的变量，不会与宏展开环境中的变量冲突。

使用 quote do: var!(a) = 1 影响 context

Elixir 用 context 对变量进行注解

第三行定义的变量  x quoted-expression 是 {:x, [line: 3], nil}

模块内的 quote do: x 是 {:x, [line: 3], Sample}

注明变量来自 Sample 模块

可以用 var! alias! 绕过 Hygiene，但必须小心使用

大部分使用可以用 Macro.var/2 动态创建变量

如 Sample

Macro.var 第二个参数是用于检测 hygiene 的。

3. environment

__ENV__ 返回 Macro.Env struct 实例

包含与编译有关的信息，当前模块，文件，行数，所有作用域内的变量，imports，requires 等

多数 Macro 模块的函数都需要 Macro.Env 为参数

4. 私有宏

类似私有函数 defmacrop

只在定义宏的模块内有用，仅在编译期有用

使用 macros 前必须定义。否则会报 runtime error。

因为 macros 不展开，而被转为函数调用，产生函数为定义的错误

5. Write macros responsibly

宏的特点

  hygiene

  lexical

  explict 有些语言，允许通过解析转换或反射在暗中重写函数，Elixir 要求必须明确调用宏

  clear 使用 quote unquote 而非 shortcuts form (' , '@)

假如你必须使用 macros。要注意 macros 不是 API。

Keep macro definitions short

这样便于测试，并提供给其他模块不依赖 macros 的 API

# 3. Domain-specific languages DSLs

1. foreword

Domain-specific language (DSL)

不需要用 macro 实现 DSL: 每个定义的数据结构，函数都是 DSL 一部分

例如在一个 Validator 数据验证模块中

可以用 data structures, functions, macros 实现

# 用 data structure
import Validator

validate user, name: [length, 1..100]
               email: [matches: ~r/@/]

# function
user
|> validate_length(:name, 1..100)
|> validate_matches(:email, ~r/@)

# modules macros

defmodule UserValidator do
  use Validator
  validate_length :name, 1..100
  validate_matches :email, ~r/@/
end

UserValidator.validate(user)

数据结构是最 flexible 的，如果你的问题可以用数据结构表示，那是最简单的实现方法。

函数适合更复杂的 API。可以传入参数，可以用 pipe 操作符

macros 是最复杂的。代码量多，难以测试，限制 library 的使用（validator 必须定义成模块）

假设要检查一个某些条件下才有的属性，通过修改数据结构可以很容易实现，通过条件可以在函数中实现，但 macro 必须能支持参数才能实现。

2. our own test case

定义 TestCase 模块，test 宏，

run 函数来运行所有模块内测试

用 = 做 assertions

3. test macro

暂时还没有运行函数

4. store information with attributes

为了执行全部测试，需要有办法能访问全部定义的 test cases

一种办法是: 通过 __MODULE__.__info__(:functions) 在运行时得到

但这不能得到除 函数名 外更多信息。还需要更灵活的方法。

之前提到，module attributes 可以用作临时存储，适合用在这里。

在 __using__/1 中定义

@tests [] 存放每个测试函数名字

@before_compile 在导入 TestCase 的模块编译前，调用 TestCase.__before_compile__/1 添加 run/0 函数

和 @before_compile 类似的还有 @on_definition @after_compile

apply(anonymous 函数, 参数列表)

apply(M, F, A) 模块，函数，参数列表

https://hexdocs.pm/elixir/Module.html#module-compile-callbacks Module — Elixir v1.10.4

???

quoted expression 可视化

=========

Misc:

serve_ch8 是 defp 时无法使用
@compile {:nowarn_unused_function, [
  serve_ch8: 1,
  serve_ch9_no_with: 1,
  write_line_ch8: 2
]}
defp serve_ch8 -> def _serve_ch8
  带有 module_attribute @ignore 的通过 macro 转为 def _func_name

NIF:
  https://cs.mcgill.ca/~mxia3/2017/06/18/tutorial-extending-elixir-with-c-using-NIF/ Tutorial: Extending Elixir with C using NIF | Meng Xuan Xia
  https://simplabs.com/blog/2020/06/25/writing-rust-nifs-for-elixir-with-rustler/ Writing Rust NIFs for Elixir With Rustler | Blog | simplabs
  https://sudonull.com/post/97911-How-to-write-your-NIF-in-Elixir How to write your NIF in Elixir / Sudo Null IT News

Erlang call Elixir

  elixirc file.ex -> Elixir.Module.beam

  erl
  > :'Elixir:Module':function_name().

Elixir call Erlang

  :erlang.
  :timer.

  file.beam
  > :file.double 4

Books:

https://subscription.packtpub.com/book/application_development/9781784397517 Elixir Cookbook

Blogs:

https://blog.appsignal.com/category/elixir-alchemy.html Elixir Alchemy email series | AppSignal Blog

https://thinkingelixir.com/ Thinking Elixir – Transforming your Mindset.
=========

https://github.com/tony612/the-zen-of-elixir tony612/the-zen-of-elixir: Collection of top articles reflecting the Zen of Elixir

iex

command
  i Prints information about the data type of any given term
  h Helper
  v Returns the value of the nth expression in the history

https://hexdocs.pm/logger/Logger.html#content Logger — Logger v1.10.4

https://elixirschool.com/en/

http://elixirstatus.com/
https://elixirweekly.net/

https://elixirforum.com
https://elixirforum.com/t/phoenix-1-5-0-rc-0-released/30693
elixirmix

sidecar pattern

Code Gist
  liveview

orm or sql builder in Elixir/Erlang

algorithm
  c
  java
  python
  elixir / erlang
  Haskell

Graph Theory algorithms
https://www.youtube.com/watch?v=09_LlHjoEiY

https://www.tutorialspoint.com/data_structures_algorithms/index.htm

MIT 6.006 算法导论
https://www.youtube.com/watch?v=OQ5jsbhAv_M

Advanced Algorithms (COMPSCI 224), Lecture 1
https://www.youtube.com/watch?v=0JUN9aDxVmI

https://www.tutorialspoint.com/design_and_analysis_of_algorithms/index.htm

https://www.tutorialspoint.com/data_structures_algorithms/index.htm

剑指offer
编程之美
